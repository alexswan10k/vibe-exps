<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Modular Synth Prototype</title>
    <style>
body {
    font-family: Arial, sans-serif;
    margin: 0;
    padding: 0;
    background-color: #222;
    color: #fff;
}

.container {
    display: flex;
    height: 100vh;
}

.module-panel {
    width: 200px;
    background-color: #333;
    padding: 20px;
    box-sizing: border-box;
}

.module-panel h2 {
    margin-top: 0;
}

.module-item {
    background-color: #444;
    padding: 10px;
    margin-bottom: 10px;
    cursor: grab;
    border-radius: 5px;
    text-align: center;
}

.module-item:hover {
    background-color: #555;
}

.rack {
    flex: 1;
    background-color: #111;
    padding: 20px;
    box-sizing: border-box;
    position: relative;
}

.rack h2 {
    margin-top: 0;
}

.rack-area {
    height: calc(100% - 40px);
    background-color: #000;
    border: 1px solid #444;
    position: relative;
    overflow: hidden;
}

.module {
    position: absolute;
    background-color: #333;
    border: 1px solid #666;
    border-radius: 5px;
    padding: 10px;
    min-width: 120px;
    min-height: 100px;
    cursor: move;
}

.module-header {
    background-color: #444;
    padding: 5px;
    margin: -10px -10px 10px -10px;
    border-radius: 5px 5px 0 0;
    cursor: move;
}

.patch-point {
    position: absolute;
    width: 10px;
    height: 10px;
    background-color: #888;
    border-radius: 50%;
    cursor: pointer;
}

.patch-point:hover {
    background-color: #aaa;
}

.patch-point.active {
    background-color: #ff0;
    box-shadow: 0 0 10px #ff0;
}

.connection {
    position: absolute;
    pointer-events: none;
    stroke: #0f0;
    stroke-width: 2;
    fill: none;
}

.potentiometer {
    width: 30px;
    height: 30px;
    background-color: #666;
    border-radius: 50%;
    margin: 5px;
    cursor: pointer;
    position: relative;
}

.potentiometer input[type="range"] {
    -webkit-appearance: none;
    appearance: none;
    width: 100%;
    height: 4px;
    background: #666;
    outline: none;
    border-radius: 2px;
}

.potentiometer input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 12px;
    height: 12px;
    background: #fff;
    border-radius: 50%;
    cursor: pointer;
}

.potentiometer input[type="range"]::-moz-range-thumb {
    width: 12px;
    height: 12px;
    background: #fff;
    border-radius: 50%;
    cursor: pointer;
    border: none;
}

.switch {
    width: 40px;
    height: 20px;
    background-color: #666;
    border-radius: 10px;
    margin: 5px;
    cursor: pointer;
    position: relative;
}

.switch input {
    opacity: 0;
    width: 0;
    height: 0;
}

.slider {
    position: absolute;
    top: 2px;
    left: 2px;
    width: 16px;
    height: 16px;
    background-color: #fff;
    border-radius: 50%;
    transition: left 0.2s;
}

.switch input:checked + .slider {
    left: 22px;
}
    </style>
    <!-- React from CDN -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
/**
 * @typedef {Object} PatchPoint
 * @property {string} id - Unique identifier for the patch point
 * @property {string} name - Display name of the patch point
 * @property {'input'|'output'} type - Whether this is an input or output
 * @property {number} x - X position relative to module
 * @property {number} y - Y position relative to module
 */

/**
 * @typedef {Object} Control
 * @property {string} id - Unique identifier for the control
 * @property {string} name - Display name of the control
 * @property {'potentiometer'|'switch'} type - Type of control
 * @property {number} value - Current value (0-1 for potentiometers, 0/1 for switches)
 * @property {number} x - X position relative to module
 * @property {number} y - Y position relative to module
 */

/**
 * @typedef {Object} Module
 * @property {string} id - Unique identifier
 * @property {string} type - Module type (oscillator, vcf, etc.)
 * @property {string} name - Display name
 * @property {number} x - X position on rack
 * @property {number} y - Y position on rack
 * @property {number} width - Module width
 * @property {number} height - Module height
 * @property {PatchPoint[]} patchPoints - Array of patch points
 * @property {Control[]} controls - Array of controls
 */

/**
 * @typedef {Object} Connection
 * @property {string} id - Unique identifier
 * @property {string} fromModuleId - ID of source module
 * @property {string} fromPatchId - ID of source patch point
 * @property {string} toModuleId - ID of destination module
 * @property {string} toPatchId - ID of destination patch point
 */

/**
 * Creates a module definition with JSDoc types
 * @param {string} type - Module type
 * @param {string} name - Display name
 * @param {number} width - Module width
 * @param {number} height - Module height
 * @param {PatchPoint[]} patchPoints - Patch points array
 * @param {Control[]} controls - Controls array
 * @returns {Omit<Module, 'id' | 'x' | 'y'>} Module template
 */
function createModuleTemplate(type, name, width, height, patchPoints, controls) {
    return {
        type,
        name,
        width,
        height,
        patchPoints: patchPoints.map((point, index) => ({
            ...point,
            id: `${type}-patch-${index}`
        })),
        controls: controls.map((control, index) => ({
            ...control,
            id: `${type}-control-${index}`,
            value: control.type === 'switch' ? 0 : 0.5
        }))
    };
}

// Module templates
const MODULE_TEMPLATES = {
    oscillator: createModuleTemplate(
        'oscillator',
        'Oscillator',
        140,
        120,
        [
            { name: 'Out', type: 'output', x: 135, y: 60 }
        ],
        [
            { name: 'Frequency', type: 'potentiometer', x: 20, y: 40 },
            { name: 'Waveform', type: 'potentiometer', x: 80, y: 40 }
        ]
    ),

    vcf: createModuleTemplate(
        'vcf',
        'VCF',
        140,
        140,
        [
            { name: 'In', type: 'input', x: -5, y: 40 },
            { name: 'Cutoff Mod', type: 'input', x: -5, y: 80 },
            { name: 'Out', type: 'output', x: 135, y: 60 }
        ],
        [
            { name: 'Cutoff', type: 'potentiometer', x: 20, y: 40 },
            { name: 'Resonance', type: 'potentiometer', x: 80, y: 40 }
        ]
    ),

    vca: createModuleTemplate(
        'vca',
        'VCA',
        140,
        120,
        [
            { name: 'Audio In', type: 'input', x: -5, y: 40 },
            { name: 'CV In', type: 'input', x: -5, y: 80 },
            { name: 'Out', type: 'output', x: 135, y: 60 }
        ],
        [
            { name: 'Level', type: 'potentiometer', x: 50, y: 40 }
        ]
    ),

    envelope: createModuleTemplate(
        'envelope',
        'Envelope',
        140,
        160,
        [
            { name: 'Gate', type: 'input', x: -5, y: 80 },
            { name: 'Out', type: 'output', x: 135, y: 80 }
        ],
        [
            { name: 'Attack', type: 'potentiometer', x: 20, y: 40 },
            { name: 'Decay', type: 'potentiometer', x: 80, y: 40 },
            { name: 'Sustain', type: 'potentiometer', x: 20, y: 80 },
            { name: 'Release', type: 'potentiometer', x: 80, y: 80 }
        ]
    ),

    'cv-gate': createModuleTemplate(
        'cv-gate',
        'CV/Gate Generator',
        140,
        120,
        [
            { name: 'CV Out', type: 'output', x: 135, y: 40 },
            { name: 'Gate Out', type: 'output', x: 135, y: 80 }
        ],
        [
            { name: 'CV Level', type: 'potentiometer', x: 20, y: 40 },
            { name: 'Gate', type: 'switch', x: 80, y: 40 }
        ]
    ),

    output: createModuleTemplate(
        'output',
        'Output',
        140,
        120,
        [
            { name: 'Audio In', type: 'input', x: -5, y: 60 }
        ],
        [
            { name: 'Volume', type: 'potentiometer', x: 50, y: 40 }
        ]
    ),

    mixer: createModuleTemplate(
        'mixer',
        'Mixer',
        160,
        140,
        [
            { name: 'In 1', type: 'input', x: -5, y: 40 },
            { name: 'In 2', type: 'input', x: -5, y: 80 },
            { name: 'Out', type: 'output', x: 155, y: 60 }
        ],
        [
            { name: 'Level 1', type: 'potentiometer', x: 30, y: 30 },
            { name: 'Level 2', type: 'potentiometer', x: 30, y: 70 },
            { name: 'Master', type: 'potentiometer', x: 100, y: 50 }
        ]
    )
};

/**
 * Creates a new module instance
 * @param {string} type - Module type
 * @param {number} x - X position
 * @param {number} y - Y position
 * @returns {Module} New module instance
 */
function createModule(type, x, y) {
    const template = MODULE_TEMPLATES[type];
    if (!template) {
        throw new Error(`Unknown module type: ${type}`);
    }

    const moduleId = `${type}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;

    return {
        id: moduleId,
        ...template,
        patchPoints: template.patchPoints.map((point, index) => ({
            ...point,
            id: `${moduleId}-patch-${index}`
        })),
        controls: template.controls.map((control, index) => ({
            ...control,
            id: `${moduleId}-control-${index}`
        })),
        x,
        y
    };
}

/**
 * Creates a new connection
 * @param {string} fromModuleId - Source module ID
 * @param {string} fromPatchId - Source patch point ID
 * @param {string} toModuleId - Destination module ID
 * @param {string} toPatchId - Destination patch point ID
 * @returns {Connection} New connection
 */
function createConnection(fromModuleId, fromPatchId, toModuleId, toPatchId) {
    return {
        id: `connection-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
        fromModuleId,
        fromPatchId,
        toModuleId,
        toPatchId
    };
}

/**
 * Audio Engine - Manages Web Audio API nodes and connections
 */
class AudioEngine {
    constructor() {
        this.audioContext = null;
        this.audioNodes = new Map();
        this.gainNodes = new Map();
        this.initialized = false;
    }

    /**
     * Initialize the audio context
     */
    async init() {
        if (this.initialized) return;

        try {
            this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            this.initialized = true;
        } catch (error) {
            console.error('Failed to initialize audio context:', error);
        }
    }

    /**
     * Create audio node for a module
     * @param {Module} module - Module data
     * @returns {AudioNode|null} Created audio node
     */
    createAudioNode(module) {
        if (!this.audioContext) return null;

        switch (module.type) {
            case 'oscillator':
                const oscillator = this.audioContext.createOscillator();
                const oscGain = this.audioContext.createGain();

                oscillator.frequency.value = 440; // Default frequency
                oscillator.type = 'sine';
                oscGain.gain.value = 0.1; // Low volume to prevent clipping

                oscillator.connect(oscGain);
                oscillator.start();

                this.audioNodes.set(module.id, oscillator);
                this.gainNodes.set(module.id, oscGain);

                return oscGain;

            case 'output':
                const outputGain = this.audioContext.createGain();
                outputGain.gain.value = 0.5; // Default volume
                outputGain.connect(this.audioContext.destination);

                this.gainNodes.set(module.id, outputGain);
                return outputGain;

            case 'vca':
                const vcaGain = this.audioContext.createGain();
                vcaGain.gain.value = 0;

                this.gainNodes.set(module.id, vcaGain);
                return vcaGain;

            case 'vcf':
                const filter = this.audioContext.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 1000;
                filter.Q.value = 1;

                this.audioNodes.set(module.id, filter);
                return filter;

            case 'envelope':
                // Simple envelope generator using gain node
                const envGain = this.audioContext.createGain();
                envGain.gain.value = 0;

                this.gainNodes.set(module.id, envGain);
                return envGain;

            default:
                // Generic gain node for other modules
                const gain = this.audioContext.createGain();
                this.gainNodes.set(module.id, gain);
                return gain;
        }
    }

    /**
     * Update audio node parameters based on module controls
     * @param {Module} module - Module data
     */
    updateModule(module) {
        if (!this.audioContext) return;

        const audioNode = this.audioNodes.get(module.id);
        const gainNode = this.gainNodes.get(module.id);

        switch (module.type) {
            case 'oscillator':
                if (audioNode) {
                    const freqControl = module.controls.find(c => c.name === 'Frequency');
                    if (freqControl) {
                        // Map 0-1 to 20-2000 Hz
                        audioNode.frequency.value = 20 + (freqControl.value * 1980);
                    }

                    const waveformControl = module.controls.find(c => c.name === 'Waveform');
                    if (waveformControl) {
                        // Map 0-1 range to sine -> square -> sawtooth
                        if (waveformControl.value < 0.33) {
                            audioNode.type = 'sine';
                        } else if (waveformControl.value < 0.66) {
                            audioNode.type = 'square';
                        } else {
                            audioNode.type = 'sawtooth';
                        }
                    }
                }
                break;

            case 'output':
                if (gainNode) {
                    const volumeControl = module.controls.find(c => c.name === 'Volume');
                    if (volumeControl) {
                        gainNode.gain.value = volumeControl.value;
                    }
                }
                break;

            case 'vcf':
                if (audioNode) {
                    const cutoffControl = module.controls.find(c => c.name === 'Cutoff');
                    if (cutoffControl) {
                        // Map 0-1 to 20-20000 Hz
                        audioNode.frequency.value = 20 + (cutoffControl.value * 19980);
                    }

                    const resonanceControl = module.controls.find(c => c.name === 'Resonance');
                    if (resonanceControl) {
                        audioNode.Q.value = 0.1 + (resonanceControl.value * 20);
                    }
                }
                break;

            case 'vca':
                if (gainNode) {
                    const levelControl = module.controls.find(c => c.name === 'Level');
                    if (levelControl) {
                        gainNode.gain.value = levelControl.value;
                    }
                }
                break;
        }
    }

    /**
     * Connect audio nodes based on connections
     * @param {Module[]} modules - All modules
     * @param {Connection[]} connections - All connections
     */
    updateConnections(modules, connections) {
        if (!this.audioContext) return;

        // First, disconnect ALL gain nodes from everything except their internal connections
        this.gainNodes.forEach((node, moduleId) => {
            try {
                // Disconnect from all destinations
                node.disconnect();
            } catch (e) {
                // Ignore disconnect errors
            }
        });

        // Reconnect internal oscillator connections (oscillator -> gain)
        this.audioNodes.forEach((node, moduleId) => {
            const module = modules.find(m => m.id === moduleId);
            if (module && module.type === 'oscillator') {
                try {
                    const gainNode = this.gainNodes.get(moduleId);
                    if (gainNode) {
                        node.connect(gainNode);
                    }
                } catch (e) {
                    // Ignore errors
                }
            }
        });

        // Now reconnect based on current connections
        connections.forEach(connection => {
            const fromModule = modules.find(m => m.id === connection.fromModuleId);
            const toModule = modules.find(m => m.id === connection.toModuleId);

            if (!fromModule || !toModule) return;

            // For source modules, use the gain node (output of the module)
            let fromNode = null;
            if (fromModule.type === 'oscillator') {
                fromNode = this.gainNodes.get(fromModule.id); // Use gain node for oscillator
            } else {
                fromNode = this.audioNodes.get(fromModule.id) || this.gainNodes.get(fromModule.id);
            }

            // For destination modules, use the appropriate input node
            let toNode = null;
            if (toModule.type === 'output') {
                toNode = this.gainNodes.get(toModule.id); // Output module's gain node
            } else {
                toNode = this.audioNodes.get(toModule.id) || this.gainNodes.get(toModule.id);
            }

            if (fromNode && toNode) {
                try {
                    fromNode.connect(toNode);
                } catch (error) {
                    console.error('Failed to connect audio nodes:', error);
                }
            }
        });

        // Ensure output modules are connected to destination only if they have input connections
        modules.forEach(module => {
            if (module.type === 'output') {
                const outputNode = this.gainNodes.get(module.id);
                if (outputNode) {
                    // Check if this output module has any input connections
                    const hasInputConnection = connections.some(conn => conn.toModuleId === module.id);
                    if (hasInputConnection) {
                        try {
                            outputNode.connect(this.audioContext.destination);
                        } catch (error) {
                            console.error('Failed to connect output to destination:', error);
                        }
                    }
                }
            }
        });
    }

    /**
     * Remove audio node for a module
     * @param {string} moduleId - Module ID
     */
    removeModule(moduleId) {
        const audioNode = this.audioNodes.get(moduleId);
        const gainNode = this.gainNodes.get(moduleId);

        if (audioNode) {
            try {
                audioNode.disconnect();
                if (audioNode.stop) audioNode.stop();
            } catch (e) {
                // Ignore errors
            }
            this.audioNodes.delete(moduleId);
        }

        if (gainNode) {
            try {
                gainNode.disconnect();
            } catch (e) {
                // Ignore errors
            }
            this.gainNodes.delete(moduleId);
        }
    }
}

const { useState, useRef, useCallback } = React;

/**
 * ModulePanel Component - Shows available modules to drag
 * @param {Object} props
 * @param {function} props.onDragStart - Called when dragging starts
 */
function ModulePanel({ onDragStart }) {
    const availableModules = [
        { type: 'oscillator', name: 'Oscillator' },
        { type: 'vcf', name: 'VCF' },
        { type: 'vca', name: 'VCA' },
        { type: 'envelope', name: 'Envelope' },
        { type: 'cv-gate', name: 'CV/Gate Generator' },
        { type: 'mixer', name: 'Mixer' },
        { type: 'output', name: 'Output' }
    ];

    return (
        <div className="module-panel">
            <h2>Modules</h2>
            {availableModules.map(module => (
                <div
                    key={module.type}
                    className="module-item"
                    draggable
                    onDragStart={(e) => onDragStart(e, module.type)}
                >
                    {module.name}
                </div>
            ))}
        </div>
    );
}

/**
 * PatchPoint Component - Individual connection point on modules
 * @param {Object} props
 * @param {import('./modules.js').PatchPoint} props.patchPoint - Patch point data
 * @param {function} props.onMouseDown - Called when mouse down on patch point
 * @param {boolean} props.isConnecting - Whether currently connecting
 * @param {string|null} props.connectionStartId - ID of connection start point
 */
function PatchPoint({ patchPoint, onMouseDown, isConnecting, connectionStartId }) {
    const handleMouseDown = useCallback((e) => {
        e.stopPropagation();
        onMouseDown(patchPoint.id);
    }, [patchPoint.id, onMouseDown]);

    const isActive = isConnecting && connectionStartId === patchPoint.id;

    return (
        <div
            className={`patch-point ${patchPoint.type} ${isActive ? 'active' : ''}`}
            style={{
                left: patchPoint.x,
                top: patchPoint.y,
                transform: 'translate(-50%, -50%)'
            }}
            onMouseDown={handleMouseDown}
            title={patchPoint.name}
        />
    );
}

/**
 * Control Component - Potentiometer or switch
 * @param {Object} props
 * @param {import('./modules.js').Control} props.control - Control data
 * @param {function} props.onChange - Called when control value changes
 */
function Control({ control, onChange }) {
    const handleChange = useCallback((e) => {
        const value = control.type === 'switch'
            ? (e.target.checked ? 1 : 0)
            : parseFloat(e.target.value);
        onChange(control.id, value);
    }, [control.id, control.type, onChange]);

    if (control.type === 'switch') {
        return (
            <div
                className="switch"
                style={{ left: control.x, top: control.y }}
                title={control.name}
            >
                <input
                    type="checkbox"
                    checked={control.value === 1}
                    onChange={handleChange}
                />
                <span className="slider"></span>
            </div>
        );
    }

    return (
        <div
            className="potentiometer"
            style={{ left: control.x, top: control.y }}
            title={control.name}
        >
            <input
                type="range"
                min="0"
                max="1"
                step="0.01"
                value={control.value}
                onChange={handleChange}
            />
        </div>
    );
}

/**
 * Module Component - Individual synth module
 * @param {Object} props
 * @param {Module} props.module - Module data
 * @param {function} props.onPatchPointMouseDown - Called when patch point clicked
 * @param {function} props.onControlChange - Called when control changes
 * @param {function} props.onModuleMove - Called when module is moved
 * @param {boolean} props.isConnecting - Whether currently connecting
 * @param {string|null} props.connectionStartId - ID of connection start point
 */
function SynthModule({ module, onPatchPointMouseDown, onControlChange, onModuleMove, isConnecting, connectionStartId }) {
    const [isDragging, setIsDragging] = useState(false);
    const [dragStart, setDragStart] = useState({ x: 0, y: 0 });
    const moduleRef = useRef(null);

    const handleMouseDown = useCallback((e) => {
        if (e.target.closest('.patch-point') || e.target.closest('.potentiometer, .switch')) {
            return; // Don't drag if clicking on patch points or controls
        }

        setIsDragging(true);
        const rect = moduleRef.current.getBoundingClientRect();
        setDragStart({
            x: e.clientX - rect.left,
            y: e.clientY - rect.top
        });
    }, []);

    const handleMouseMove = useCallback((e) => {
        if (!isDragging) return;

        const rackArea = moduleRef.current.parentElement;
        const rackRect = rackArea.getBoundingClientRect();

        const newX = Math.max(0, Math.min(
            e.clientX - rackRect.left - dragStart.x,
            rackRect.width - module.width
        ));
        const newY = Math.max(0, Math.min(
            e.clientY - rackRect.top - dragStart.y,
            rackRect.height - module.height
        ));

        onModuleMove(module.id, newX, newY);
    }, [isDragging, dragStart, module.id, module.width, module.height, onModuleMove]);

    const handleMouseUp = useCallback(() => {
        setIsDragging(false);
    }, []);

    // Add global mouse event listeners when dragging
    React.useEffect(() => {
        if (isDragging) {
            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);
            return () => {
                document.removeEventListener('mousemove', handleMouseMove);
                document.removeEventListener('mouseup', handleMouseUp);
            };
        }
    }, [isDragging, handleMouseMove, handleMouseUp]);

    return (
        <div
            ref={moduleRef}
            className="module"
            style={{
                left: module.x,
                top: module.y,
                width: module.width,
                height: module.height,
                cursor: isDragging ? 'grabbing' : 'grab'
            }}
            onMouseDown={handleMouseDown}
        >
            <div className="module-header">{module.name}</div>

            {module.patchPoints.map(patchPoint => (
                <React.Fragment key={patchPoint.id}>
                    <PatchPoint
                        patchPoint={patchPoint}
                        onMouseDown={onPatchPointMouseDown}
                        isConnecting={isConnecting}
                        connectionStartId={connectionStartId}
                    />
                    <div
                        style={{
                            position: 'absolute',
                            left: patchPoint.type === 'input' ? patchPoint.x + 8 : patchPoint.x - 35,
                            top: patchPoint.y - 8,
                            fontSize: '10px',
                            color: '#ccc',
                            pointerEvents: 'none',
                            whiteSpace: 'nowrap',
                            fontWeight: 'bold'
                        }}
                    >
                        {patchPoint.name}
                    </div>
                </React.Fragment>
            ))}

            {module.controls.map(control => (
                <Control
                    key={control.id}
                    control={control}
                    onChange={onControlChange}
                />
            ))}
        </div>
    );
}

/**
 * ConnectionLine Component - Visual connection between modules
 * @param {Object} props
 * @param {Connection} props.connection - Connection data
 * @param {Module[]} props.modules - All modules
 * @param {function} props.onRemove - Called when connection is clicked for removal
 */
function ConnectionLine({ connection, modules, onRemove }) {
    const getPatchPointPosition = useCallback((moduleId, patchId) => {
        const module = modules.find(m => m.id === moduleId);
        if (!module) return null;

        const patchPoint = module.patchPoints.find(p => p.id === patchId);
        if (!patchPoint) return null;

        return {
            x: module.x + patchPoint.x,
            y: module.y + patchPoint.y
        };
    }, [modules]);

    const fromPos = getPatchPointPosition(connection.fromModuleId, connection.fromPatchId);
    const toPos = getPatchPointPosition(connection.toModuleId, connection.toPatchId);

    if (!fromPos || !toPos) return null;

    const dx = toPos.x - fromPos.x;
    const dy = toPos.y - fromPos.y;
    const distance = Math.sqrt(dx * dx + dy * dy);

    // Create curved path
    const midX = (fromPos.x + toPos.x) / 2;
    const midY = (fromPos.y + toPos.y) / 2;
    const controlOffset = Math.abs(dx) > Math.abs(dy) ? Math.abs(dx) * 0.3 : Math.abs(dy) * 0.3;

    const pathData = `M ${fromPos.x} ${fromPos.y} Q ${midX} ${fromPos.y} ${midX} ${midY} Q ${midX} ${toPos.y} ${toPos.x} ${toPos.y}`;

    return (
        <svg
            className="connection"
            style={{
                position: 'absolute',
                top: 0,
                left: 0,
                width: '100%',
                height: '100%',
                pointerEvents: 'none',
                zIndex: 1
            }}
        >
            <path
                d={pathData}
                stroke="#0f0"
                strokeWidth="2"
                fill="none"
                style={{ pointerEvents: 'stroke', cursor: 'pointer' }}
                onClick={(e) => {
                    e.stopPropagation();
                    onRemove(connection.id);
                }}
            />
        </svg>
    );
}

/**
 * Rack Component - Main synthesis area
 * @param {Object} props
 * @param {Module[]} props.modules - Array of modules
 * @param {Connection[]} props.connections - Array of connections
 * @param {function} props.onDrop - Called when item is dropped
 * @param {function} props.onPatchPointMouseDown - Called when patch point clicked
 * @param {function} props.onControlChange - Called when control changes
 * @param {function} props.onModuleMove - Called when module is moved
 * @param {function} props.onConnectionRemove - Called when connection is removed
 * @param {boolean} props.isConnecting - Whether currently connecting
 * @param {string|null} props.connectionStartId - ID of connection start point
 */
function Rack({
    modules,
    connections,
    onDrop,
    onPatchPointMouseDown,
    onControlChange,
    onModuleMove,
    onConnectionRemove,
    isConnecting,
    connectionStartId
}) {
    const rackRef = useRef(null);

    const handleDragOver = useCallback((e) => {
        e.preventDefault();
    }, []);

    const handleDrop = useCallback((e) => {
        e.preventDefault();
        const type = e.dataTransfer.getData('text/plain');
        if (type && rackRef.current) {
            const rect = rackRef.current.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            onDrop(type, x, y);
        }
    }, [onDrop]);

    return (
        <div className="rack">
            <h2>Rack</h2>
            <div
                ref={rackRef}
                className="rack-area"
                onDragOver={handleDragOver}
                onDrop={handleDrop}
            >
                {modules.map(module => (
                    <SynthModule
                        key={module.id}
                        module={module}
                        onPatchPointMouseDown={onPatchPointMouseDown}
                        onControlChange={onControlChange}
                        onModuleMove={onModuleMove}
                        isConnecting={isConnecting}
                        connectionStartId={connectionStartId}
                    />
                ))}

                {connections.map(connection => (
                    <ConnectionLine
                        key={connection.id}
                        connection={connection}
                        modules={modules}
                        onRemove={onConnectionRemove}
                    />
                ))}
            </div>
        </div>
    );
}

/**
 * Main App Component
 */
function App() {
    /** @type {[Module[], function]} */
    const [modules, setModules] = useState([]);
    /** @type {[Connection[], function]} */
    const [connections, setConnections] = useState([]);
    /** @type {[boolean, function]} */
    const [isConnecting, setIsConnecting] = useState(false);
    /** @type {[string|null, function]} */
    const [connectionStart, setConnectionStart] = useState(null);
    /** @type {[AudioEngine, function]} */
    const [audioEngine, setAudioEngine] = useState(null);

    // Initialize audio engine
    React.useEffect(() => {
        const engine = new AudioEngine();
        engine.init().then(() => {
            setAudioEngine(engine);
        });
    }, []);

    // Resume audio context on user interaction
    React.useEffect(() => {
        const resumeAudio = async () => {
            if (audioEngine && audioEngine.audioContext && audioEngine.audioContext.state === 'suspended') {
                try {
                    await audioEngine.audioContext.resume();
                    console.log('Audio context resumed');
                } catch (error) {
                    console.error('Failed to resume audio context:', error);
                }
            }
        };

        const handleInteraction = () => {
            resumeAudio();
            // Remove listeners after first interaction
            document.removeEventListener('click', handleInteraction);
            document.removeEventListener('keydown', handleInteraction);
        };

        document.addEventListener('click', handleInteraction);
        document.addEventListener('keydown', handleInteraction);

        return () => {
            document.removeEventListener('click', handleInteraction);
            document.removeEventListener('keydown', handleInteraction);
        };
    }, [audioEngine]);

    // Create audio nodes when modules are added
    React.useEffect(() => {
        if (!audioEngine) return;

        modules.forEach(module => {
            if (!audioEngine.audioNodes.has(module.id) && !audioEngine.gainNodes.has(module.id)) {
                audioEngine.createAudioNode(module);
            }
        });
    }, [modules, audioEngine]);

    // Update audio parameters when modules change
    React.useEffect(() => {
        if (!audioEngine) return;

        modules.forEach(module => {
            audioEngine.updateModule(module);
        });
    }, [modules, audioEngine]);

    // Update audio connections when connections change
    React.useEffect(() => {
        if (!audioEngine) return;

        audioEngine.updateConnections(modules, connections);
    }, [connections, modules, audioEngine]);

    /**
     * Handle module creation from drag and drop
     * @param {string} type - Module type
     * @param {number} x - X position
     * @param {number} y - Y position
     */
    const handleModuleDrop = useCallback((type, x, y) => {
        try {
            const newModule = createModule(type, x, y);
            setModules(prev => [...prev, newModule]);
        } catch (error) {
            console.error('Error creating module:', error);
        }
    }, []);

    /**
     * Handle patch point mouse down for connections
     * @param {string} patchPointId - ID of clicked patch point
     */
    const handlePatchPointMouseDown = useCallback((patchPointId) => {
        if (!isConnecting) {
            // Start connection
            setIsConnecting(true);
            setConnectionStart(patchPointId);
        } else {
            // Complete connection
            if (connectionStart && connectionStart !== patchPointId) {
                // Find modules and patch points
                let fromModule = null;
                let fromPatch = null;
                let toModule = null;
                let toPatch = null;

                for (const module of modules) {
                    const fromPatchPoint = module.patchPoints.find(p => p.id === connectionStart);
                    const toPatchPoint = module.patchPoints.find(p => p.id === patchPointId);

                    if (fromPatchPoint) {
                        fromModule = module;
                        fromPatch = fromPatchPoint;
                    }
                    if (toPatchPoint) {
                        toModule = module;
                        toPatch = toPatchPoint;
                    }
                }

                if (fromModule && fromPatch && toModule && toPatch) {
                    // Validate connection (output to input)
                    if (fromPatch.type === 'output' && toPatch.type === 'input') {
                        const newConnection = createConnection(
                            fromModule.id,
                            fromPatch.id,
                            toModule.id,
                            toPatch.id
                        );
                        setConnections(prev => [...prev, newConnection]);
                    }
                }
            }

            setIsConnecting(false);
            setConnectionStart(null);
        }
    }, [isConnecting, connectionStart, modules]);

    /**
     * Handle control value changes
     * @param {string} controlId - ID of control
     * @param {number} value - New value
     */
    const handleControlChange = useCallback((controlId, value) => {
        setModules(prev => prev.map(module => ({
            ...module,
            controls: module.controls.map(control =>
                control.id === controlId ? { ...control, value } : control
            )
        })));
    }, []);

    /**
     * Handle module movement
     * @param {string} moduleId - ID of module
     * @param {number} x - New X position
     * @param {number} y - New Y position
     */
    const handleModuleMove = useCallback((moduleId, x, y) => {
        setModules(prev => prev.map(module =>
            module.id === moduleId ? { ...module, x, y } : module
        ));
    }, []);

    /**
     * Handle connection removal
     * @param {string} connectionId - ID of connection to remove
     */
    const handleConnectionRemove = useCallback((connectionId) => {
        setConnections(prev => {
            const newConnections = prev.filter(conn => conn.id !== connectionId);
            // Audio connections will be updated via useEffect when connections state changes
            return newConnections;
        });
    }, []);

    /**
     * Handle drag start from module panel
     * @param {DragEvent} e - Drag event
     * @param {string} type - Module type
     */
    const handleDragStart = useCallback((e, type) => {
        e.dataTransfer.setData('text/plain', type);
    }, []);

    return (
        <div className="container">
            <ModulePanel onDragStart={handleDragStart} />
            <Rack
                modules={modules}
                connections={connections}
                onDrop={handleModuleDrop}
                onPatchPointMouseDown={handlePatchPointMouseDown}
                onControlChange={handleControlChange}
                onModuleMove={handleModuleMove}
                onConnectionRemove={handleConnectionRemove}
                isConnecting={isConnecting}
                connectionStartId={connectionStart}
            />
        </div>
    );
}

// Render the React app
const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<App />);
    </script>
</body>
</html>
