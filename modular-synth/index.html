<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Modular Synth Prototype</title>
    <style>
        :root {
            --bg-color: #1a1a1a;
            --rack-bg: #121212;
            --module-bg: #2a2a2a;
            --module-header-bg: #333;
            --text-color: #eee;
            --accent-color: #4CAF50;
            --knob-color: #ddd;
            --jack-color: #666;
            --cable-color: #76ff03;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            overflow: hidden; /* Prevent body scroll */
        }

        .container {
            display: flex;
            height: 100vh;
        }

        /* Sidebar */
        .module-panel {
            width: 220px;
            background-color: #222;
            padding: 20px;
            box-sizing: border-box;
            border-right: 1px solid #444;
            display: flex;
            flex-direction: column;
            gap: 10px;
            overflow-y: auto;
            z-index: 10;
        }

        .module-panel h2 {
            margin-top: 0;
            font-size: 1.2rem;
            color: #fff;
            border-bottom: 2px solid #444;
            padding-bottom: 10px;
        }

        .module-item {
            background-color: #333;
            padding: 12px;
            cursor: grab;
            border-radius: 4px;
            text-align: left;
            border: 1px solid #444;
            transition: background-color 0.2s, transform 0.1s;
            display: flex;
            align-items: center;
            font-size: 0.9rem;
        }

        .module-item:hover {
            background-color: #444;
            border-color: #666;
            transform: translateX(5px);
        }

        .module-item:active {
            cursor: grabbing;
        }

        /* Main Rack Area */
        .rack {
            flex: 1;
            background-color: var(--rack-bg);
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .rack-header {
            padding: 15px 20px;
            background-color: #1a1a1a;
            border-bottom: 1px solid #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 10;
        }

        .rack-header h2 {
            margin: 0;
            font-size: 1.2rem;
        }

        .controls {
            display: flex;
            gap: 10px;
        }

        .btn {
            background-color: #444;
            color: #fff;
            border: 1px solid #555;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s;
        }

        .btn:hover {
            background-color: #555;
            border-color: #777;
        }

        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
        }

        .file-input-wrapper input[type=file] {
            position: absolute;
            left: 0;
            top: 0;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }

        .rack-area {
            flex: 1;
            position: relative;
            overflow: hidden;
            background-image: 
                linear-gradient(rgba(255, 255, 255, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 255, 255, 0.03) 1px, transparent 1px);
            background-size: 20px 20px;
        }

        /* Modules */
        .module {
            position: absolute;
            background-color: var(--module-bg);
            border: 1px solid #555;
            border-radius: 6px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            display: flex;
            flex-direction: column;
            user-select: none;
            /* Default size, can be overridden */
            width: 160px; 
            min-height: 200px;
        }

        .module-header {
            background-color: var(--module-header-bg);
            padding: 8px;
            border-radius: 5px 5px 0 0;
            cursor: move;
            border-bottom: 1px solid #444;
            font-weight: bold;
            font-size: 0.9rem;
            text-align: center;
            letter-spacing: 0.5px;
            text-transform: uppercase;
        }

        .module-body {
            flex: 1;
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        /* Controls Area */
        .controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(50px, 1fr));
            gap: 10px;
            justify-items: center;
            align-items: start;
        }

        .control-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }

        .control-label {
            font-size: 0.7rem;
            color: #aaa;
            text-align: center;
        }

        /* Potentiometer */
        .knob {
            width: 40px;
            height: 40px;
            background: radial-gradient(circle, #444 0%, #222 100%);
            border-radius: 50%;
            position: relative;
            cursor: ns-resize; /* Vertical drag */
            border: 2px solid #555;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .knob::after {
            content: '';
            position: absolute;
            top: 5px;
            left: 50%;
            width: 2px;
            height: 15px;
            background-color: #fff;
            transform-origin: bottom center;
            transform: translateX(-50%) rotate(var(--rotation));
            pointer-events: none;
        }

        /* Switch */
        .toggle-switch {
            width: 40px;
            height: 20px;
            background-color: #222;
            border-radius: 10px;
            position: relative;
            cursor: pointer;
            border: 1px solid #555;
        }

        .toggle-switch::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 14px;
            height: 14px;
            background-color: #888;
            border-radius: 50%;
            transition: left 0.2s;
        }

        .toggle-switch.active {
            background-color: #2e4c2e;
        }

        .toggle-switch.active::after {
            left: 22px;
            background-color: var(--accent-color);
        }

        /* Patch Points */
        .io-panel {
            margin-top: auto;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: space-between;
            border-top: 1px solid #333;
            padding-top: 10px;
        }

        .io-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }

        .jack {
            width: 24px;
            height: 24px;
            background-color: #333;
            border: 2px solid #666;
            border-radius: 50%;
            position: relative;
            cursor: crosshair;
            box-sizing: border-box;
            transition: border-color 0.2s;
        }

        .jack::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 8px;
            height: 8px;
            background-color: #000;
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }

        .jack:hover {
            border-color: #999;
        }

        .jack.active {
            border-color: #ff0;
            box-shadow: 0 0 5px #ff0;
        }

        .jack.input { border-color: #666; }
        .jack.output { border-color: #888; background-color: #444; }

        .jack-label {
            font-size: 0.65rem;
            color: #888;
            text-transform: uppercase;
        }

        /* Cables */
        .cables-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
        }

        .cable-path {
            fill: none;
            stroke-width: 3;
            stroke-linecap: round;
            opacity: 0.8;
            pointer-events: stroke;
            cursor: pointer;
            transition: stroke-width 0.2s;
        }
        
        .cable-path:hover {
            stroke-width: 5;
            opacity: 1;
        }

        /* Specific Module Styles */
        .step-sequencer-grid {
            display: flex;
            gap: 5px;
            justify-content: center;
            margin-bottom: 10px;
        }
        
        .step-btn {
            width: 30px;
            height: 30px;
            border: 1px solid #555;
            background: #222;
            color: #555;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
        }
        
        .step-btn.active {
            background: var(--accent-color);
            color: #fff;
            border-color: var(--accent-color);
            box-shadow: 0 0 5px var(--accent-color);
        }
        
        .step-btn.current {
            border-color: #fff;
            transform: scale(1.1);
        }

        canvas.oscilloscope-display {
            width: 100%;
            height: 80px;
            background: #000;
            border: 1px solid #444;
            border-radius: 4px;
            margin-bottom: 10px;
        }
    </style>
    <!-- React from CDN -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        // --- Types & Config ---

        const MODULE_DEFINITIONS = {
            oscillator: {
                name: 'Oscillator',
                width: 180,
                controls: [
                    { id: 'freq', name: 'Frequency', type: 'knob', default: 0.25 },
                    { id: 'wave', name: 'Waveform', type: 'knob', default: 0 }
                ],
                inputs: [
                    { id: 'voct', name: 'V/Oct' },
                    { id: 'fm', name: 'FM' }
                ],
                outputs: [
                    { id: 'out', name: 'Out' }
                ]
            },
            vcf: {
                name: 'Filter (VCF)',
                width: 160,
                controls: [
                    { id: 'cutoff', name: 'Cutoff', type: 'knob', default: 0.5 },
                    { id: 'res', name: 'Res', type: 'knob', default: 0 }
                ],
                inputs: [
                    { id: 'in', name: 'In' },
                    { id: 'mod', name: 'Mod' }
                ],
                outputs: [
                    { id: 'out', name: 'Out' }
                ]
            },
            vca: {
                name: 'Amplifier (VCA)',
                width: 140,
                controls: [
                    { id: 'level', name: 'Level', type: 'knob', default: 0 }
                ],
                inputs: [
                    { id: 'in', name: 'In' },
                    { id: 'cv', name: 'CV' }
                ],
                outputs: [
                    { id: 'out', name: 'Out' }
                ]
            },
            envelope: {
                name: 'Envelope (ADSR)',
                width: 200,
                controls: [
                    { id: 'a', name: 'A', type: 'knob', default: 0.1 },
                    { id: 'd', name: 'D', type: 'knob', default: 0.2 },
                    { id: 's', name: 'S', type: 'knob', default: 0.5 },
                    { id: 'r', name: 'R', type: 'knob', default: 0.3 }
                ],
                inputs: [
                    { id: 'gate', name: 'Gate' }
                ],
                outputs: [
                    { id: 'out', name: 'Out' }
                ]
            },
            mixer: {
                name: 'Mixer',
                width: 180,
                controls: [
                    { id: 'lvl1', name: 'Ch 1', type: 'knob', default: 0.5 },
                    { id: 'lvl2', name: 'Ch 2', type: 'knob', default: 0.5 },
                    { id: 'lvl3', name: 'Ch 3', type: 'knob', default: 0.5 },
                    { id: 'master', name: 'Master', type: 'knob', default: 0.8 }
                ],
                inputs: [
                    { id: 'in1', name: 'In 1' },
                    { id: 'in2', name: 'In 2' },
                    { id: 'in3', name: 'In 3' }
                ],
                outputs: [
                    { id: 'out', name: 'Out' }
                ]
            },
            lfo: {
                name: 'LFO',
                width: 140,
                controls: [
                    { id: 'freq', name: 'Rate', type: 'knob', default: 0.2 },
                    { id: 'amt', name: 'Amt', type: 'knob', default: 1 }
                ],
                inputs: [],
                outputs: [
                    { id: 'out', name: 'Out' }
                ]
            },
            sequencer: {
                name: 'Sequencer',
                width: 220,
                controls: [
                    { id: 'tempo', name: 'Tempo', type: 'knob', default: 0.5 },
                    { id: 'run', name: 'Run', type: 'switch', default: 0 }
                ],
                inputs: [],
                outputs: [
                    { id: 'cv', name: 'CV' },
                    { id: 'gate', name: 'Gate' }
                ]
            },
            oscilloscope: {
                name: 'Oscilloscope',
                width: 200,
                controls: [],
                inputs: [
                    { id: 'in', name: 'In' }
                ],
                outputs: []
            },
            output: {
                name: 'Master Output',
                width: 140,
                controls: [
                    { id: 'vol', name: 'Volume', type: 'knob', default: 0.5 }
                ],
                inputs: [
                    { id: 'in', name: 'L/Mono' }
                ],
                outputs: []
            }
        };

        // --- Audio Engine ---
        class AudioEngine {
            constructor() {
                this.ctx = null;
                this.nodes = new Map(); // Map<moduleId, AudioNode|Object>
                this.initialized = false;
            }

            async init() {
                if (this.initialized) {
                    if (this.ctx && this.ctx.state === 'suspended') {
                        await this.ctx.resume();
                    }
                    return;
                }
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AudioContext();
                this.initialized = true;
            }

            getFrequency(val) {
                // Exponential mapping for frequency
                // 0 -> 20Hz, 1 -> 2000Hz (roughly)
                // Using formula: 20 * (100 ^ val)
                return 20 * Math.pow(100, val);
            }

            // Create nodes for a module
            createModule(module) {
                if (!this.ctx) return;
                const id = module.id;
                
                switch(module.type) {
                    case 'oscillator':
                        const osc = this.ctx.createOscillator();
                        const oscGain = this.ctx.createGain(); // Output gain
                        const fmGain = this.ctx.createGain(); // FM depth
                        
                        osc.type = 'sine';
                        osc.start();
                        osc.connect(oscGain);
                        
                        // FM setup
                        fmGain.gain.value = 500; // FM index
                        fmGain.connect(osc.frequency);

                        this.nodes.set(id, { 
                            main: oscGain, 
                            inputs: { 
                                voct: osc.frequency, 
                                fm: fmGain 
                            }, 
                            core: osc 
                        });
                        break;

                    case 'vcf':
                        const filter = this.ctx.createBiquadFilter();
                        const modGain = this.ctx.createGain();
                        
                        filter.type = 'lowpass';
                        modGain.connect(filter.frequency);
                        modGain.gain.value = 1000; // Mod depth

                        this.nodes.set(id, { 
                            main: filter, 
                            inputs: { 
                                in: filter, 
                                mod: modGain 
                            }, 
                            core: filter 
                        });
                        break;
                    
                    case 'vca':
                        const vca = this.ctx.createGain();
                        const cvGain = this.ctx.createGain();
                        vca.gain.value = 0;
                        cvGain.connect(vca.gain);
                        
                        this.nodes.set(id, { 
                            main: vca, 
                            inputs: { 
                                in: vca, 
                                cv: cvGain 
                            }, 
                            core: vca 
                        });
                        break;

                    case 'envelope':
                        // Envelopes don't process audio, they generate CV.
                        // We use a constant source for output that we modulate.
                        const envOut = this.ctx.createConstantSource();
                        envOut.offset.value = 0;
                        envOut.start();
                        
                        this.nodes.set(id, { 
                            main: envOut, 
                            inputs: { gate: null }, // Special handling for gate
                            core: envOut,
                            state: { stage: 'idle', val: 0, time: 0 }
                        });
                        break;

                    case 'mixer':
                        const master = this.ctx.createGain();
                        const ch1 = this.ctx.createGain();
                        const ch2 = this.ctx.createGain();
                        const ch3 = this.ctx.createGain();
                        
                        ch1.connect(master);
                        ch2.connect(master);
                        ch3.connect(master);
                        
                        this.nodes.set(id, { 
                            main: master, 
                            inputs: { 
                                in1: ch1, 
                                in2: ch2, 
                                in3: ch3 
                            },
                            chGains: [ch1, ch2, ch3]
                        });
                        break;
                    
                    case 'lfo':
                        const lfo = this.ctx.createOscillator();
                        const lfoAmp = this.ctx.createGain();
                        lfo.connect(lfoAmp);
                        lfo.start();
                        
                        this.nodes.set(id, {
                            main: lfoAmp,
                            core: lfo,
                            amp: lfoAmp
                        });
                        break;

                    case 'output':
                        const outGain = this.ctx.createGain();
                        outGain.connect(this.ctx.destination);
                        this.nodes.set(id, {
                            main: null, // No output to other modules
                            inputs: { in: outGain },
                            core: outGain
                        });
                        break;
                        
                    case 'oscilloscope':
                        const analyser = this.ctx.createAnalyser();
                        analyser.fftSize = 2048;
                        this.nodes.set(id, {
                            main: null,
                            inputs: { in: analyser },
                            core: analyser
                        });
                        break;

                    case 'sequencer':
                        // Sequencer outputs CV/Gate.
                        const seqCv = this.ctx.createConstantSource();
                        const seqGate = this.ctx.createConstantSource();
                        seqCv.start();
                        seqGate.start();
                        
                        this.nodes.set(id, {
                            main: null, // multiple outputs
                            outputs: { cv: seqCv, gate: seqGate },
                            inputs: {}
                        });
                        break;
                }
            }

            updateModule(module) {
                if (!this.ctx || !this.nodes.has(module.id)) return;
                const nodeData = this.nodes.get(module.id);
                
                // Helper to get control val
                const getVal = (id) => {
                    const c = module.controls.find(c => c.id === id);
                    return c ? c.value : 0;
                }

                switch(module.type) {
                    case 'oscillator':
                        const freqVal = getVal('freq');
                        const waveVal = getVal('wave');
                        
                        // Freq: 20Hz to 2000Hz (approx)
                        // Simple linear mapping for now: 20 + val * 1000
                        const freq = 20 + (freqVal * 2000);
                        nodeData.core.frequency.setTargetAtTime(freq, this.ctx.currentTime, 0.05);
                        
                        // Waveform blending (discrete for simple osc)
                        if (waveVal < 0.33) nodeData.core.type = 'sine';
                        else if (waveVal < 0.66) nodeData.core.type = 'square';
                        else nodeData.core.type = 'sawtooth';
                        break;
                        
                    case 'vcf':
                        const cutoff = getVal('cutoff');
                        const res = getVal('res');
                        // 20Hz to 10kHz
                        nodeData.core.frequency.setTargetAtTime(20 + cutoff * 10000, this.ctx.currentTime, 0.05);
                        nodeData.core.Q.value = res * 20;
                        break;
                        
                    case 'vca':
                        // Initial gain set by 'Level' knob + CV
                        // We set the base gain, CV adds to it.
                        // Actually, better: VCA usually closed (0) and opened by Env.
                        // 'Level' knob acts as offset or input attenuator? 
                        // Let's make 'Level' knob a bias (drone) or max volume.
                        // Standard VCA: Output = In * (LevelKnob + CV)
                        // If we implement CV scaling, it gets complex.
                        // Simple version: Level is bias.
                        // nodeData.core.gain.value = getVal('level'); 
                        // BUT, if we have CV connection, we rely on that.
                        // Let's make Level knob set the MAXIMUM gain the CV can reach, 
                        // OR acting as a manual offset.
                        // Let's say Level is manual offset.
                        nodeData.core.gain.setTargetAtTime(getVal('level'), this.ctx.currentTime, 0.05);
                        break;

                    case 'mixer':
                        nodeData.chGains[0].gain.value = getVal('lvl1');
                        nodeData.chGains[1].gain.value = getVal('lvl2');
                        nodeData.chGains[2].gain.value = getVal('lvl3');
                        nodeData.main.gain.value = getVal('master');
                        break;

                    case 'lfo':
                        // 0.1Hz to 20Hz
                        const lfoFreq = 0.1 + (getVal('freq') * 20);
                        nodeData.core.frequency.value = lfoFreq;
                        nodeData.amp.gain.value = getVal('amt') * 1000; // Scale for modulation
                        break;

                    case 'output':
                        nodeData.core.gain.value = getVal('vol');
                        break;
                    
                    case 'envelope':
                        // Updates occur on trigger
                        nodeData.params = {
                            a: getVal('a'),
                            d: getVal('d'),
                            s: getVal('s'),
                            r: getVal('r')
                        };
                        break;
                }
            }

            triggerEnvelope(moduleId, gateOpen) {
                if (!this.ctx) return;
                const nodeData = this.nodes.get(moduleId);
                if (!nodeData || !nodeData.params) return;
                
                const { a, d, s, r } = nodeData.params;
                const now = this.ctx.currentTime;
                const target = nodeData.core.offset;

                // Max envelope value is 1 (which usually corresponds to e.g. 1000Hz mod or 1.0 gain)
                
                target.cancelScheduledValues(now);
                
                if (gateOpen) {
                    // Attack
                    target.setValueAtTime(target.value, now);
                    target.linearRampToValueAtTime(1, now + (a * 2) + 0.005);
                    // Decay to Sustain
                    target.linearRampToValueAtTime(s, now + (a * 2) + (d * 2) + 0.005);
                } else {
                    // Release
                    target.setValueAtTime(target.value, now);
                    target.linearRampToValueAtTime(0, now + (r * 2) + 0.005);
                }
            }
            
            updateSequencer(moduleId, cvValue, gateValue) {
                const nodeData = this.nodes.get(moduleId);
                if (nodeData && nodeData.outputs) {
                    nodeData.outputs.cv.offset.value = cvValue; // 0-1 (mapped later to freq)
                    nodeData.outputs.gate.offset.value = gateValue;
                }
            }

            connect(fromId, fromPatch, toId, toPatch) {
                const source = this.nodes.get(fromId);
                const dest = this.nodes.get(toId);
                if (!source || !dest) return;

                // Determine source node
                let srcNode = source.main;
                if (source.outputs && source.outputs[fromPatch]) {
                    srcNode = source.outputs[fromPatch];
                }

                // Determine dest node
                let dstNode = null;
                if (dest.inputs && dest.inputs[toPatch]) {
                    dstNode = dest.inputs[toPatch];
                } else if (toPatch === 'gate' && dest.inputs.gate === null) {
                    // Special case for envelope gate input (handled logically, not audio-wise mostly)
                    // But for visual consistency we might need to track it. 
                    // Wait, Env Gate is logic. We need to listen to the source.
                    // If source is Gate/Square LFO, we can use a ScriptProcessor or Analyser? 
                    // For this prototype, we'll cheat: 
                    // If connecting Sequencer Gate -> Env Gate, we handle it in React logic via events if possible,
                    // OR we use the audio graph. 
                    // Let's use audio graph: connect to a gain node, and monitor it?
                    // Too complex for single file. 
                    // Fallback: Sequencer Logic triggers Envelope Logic directly in React state if connected.
                    return; 
                }

                if (srcNode && dstNode) {
                    try { srcNode.connect(dstNode); } catch(e) {}
                }
            }

            disconnectAll() {
                if(!this.ctx) return;
                this.nodes.forEach(n => {
                    // Do NOT disconnect n.core if it's different from n.main (internal wiring)
                    // Only disconnect the nodes that connect to OTHER modules
                    
                    // If core IS main (like VCF/VCA), it gets disconnected by main check below.
                    // If core connects to main (Osc/LFO), we MUST keep core->main connection.
                    
                    if (n.main && n.main.disconnect) n.main.disconnect();
                    if (n.outputs) Object.values(n.outputs).forEach(o => o.disconnect());
                });
            }
        }

        // --- React Components ---

        const { useState, useEffect, useRef, useLayoutEffect, useMemo } = React;

        function Knob({ label, value, onChange }) {
            const [dragging, setDragging] = useState(false);
            const [startY, setStartY] = useState(0);
            const [startVal, setStartVal] = useState(0);

            const handleMouseDown = (e) => {
                e.stopPropagation();
                setDragging(true);
                setStartY(e.clientY);
                setStartVal(value);
            };

            useEffect(() => {
                const handleMouseMove = (e) => {
                    if (!dragging) return;
                    const delta = startY - e.clientY;
                    // sensitivity 
                    const change = delta * 0.005; 
                    let newVal = Math.max(0, Math.min(1, startVal + change));
                    onChange(newVal);
                };

                const handleMouseUp = () => {
                    setDragging(false);
                };

                if (dragging) {
                    window.addEventListener('mousemove', handleMouseMove);
                    window.addEventListener('mouseup', handleMouseUp);
                }
                return () => {
                    window.removeEventListener('mousemove', handleMouseMove);
                    window.removeEventListener('mouseup', handleMouseUp);
                };
            }, [dragging, startY, startVal, onChange]);

            // Map 0-1 to -135deg to +135deg
            const rotation = -135 + (value * 270);

            return (
                <div className="control-wrapper">
                    <div 
                        className="knob" 
                        style={{ '--rotation': `${rotation}deg` }}
                        onMouseDown={handleMouseDown}
                        title={`${label}: ${(value * 100).toFixed(0)}%`}
                    ></div>
                    <span className="control-label">{label}</span>
                </div>
            );
        }

        function Switch({ label, value, onChange }) {
            return (
                <div className="control-wrapper">
                    <div 
                        className={`toggle-switch ${value ? 'active' : ''}`}
                        onClick={(e) => {
                            e.stopPropagation();
                            onChange(value ? 0 : 1);
                        }}
                    ></div>
                    <span className="control-label">{label}</span>
                </div>
            );
        }

        function Jack({ id, label, type, active, onMouseDown }) {
            return (
                <div className="io-group">
                    <div 
                        id={id}
                        className={`jack ${type} ${active ? 'active' : ''}`}
                        onMouseDown={(e) => {
                            e.stopPropagation();
                            onMouseDown(id, type);
                        }}
                        title={label}
                    ></div>
                    <span className="jack-label">{label}</span>
                </div>
            );
        }

        function SequencerDisplay({ stepValues, currentStep, onStepToggle }) {
            return (
                <div className="step-sequencer-grid">
                    {stepValues.map((val, idx) => (
                        <div 
                            key={idx}
                            className={`step-btn ${val > 0 ? 'active' : ''} ${currentStep === idx ? 'current' : ''}`}
                            onClick={(e) => { e.stopPropagation(); onStepToggle(idx); }}
                        >
                            {idx + 1}
                        </div>
                    ))}
                </div>
            );
        }

        function OscilloscopeDisplay({ moduleId, audioEngine }) {
            const canvasRef = useRef(null);
            
            useEffect(() => {
                if (!audioEngine || !audioEngine.nodes.has(moduleId)) return;
                const nodeData = audioEngine.nodes.get(moduleId);
                const analyser = nodeData.core;
                if (!analyser || !canvasRef.current) return;

                const ctx = canvasRef.current.getContext('2d');
                const bufferLength = analyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);
                let afId;

                const draw = () => {
                    analyser.getByteTimeDomainData(dataArray);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                    ctx.lineWidth = 2;
                    ctx.strokeStyle = '#0f0';
                    ctx.beginPath();
                    
                    const sliceWidth = ctx.canvas.width / bufferLength;
                    let x = 0;
                    for (let i = 0; i < bufferLength; i++) {
                        const v = dataArray[i] / 128.0;
                        const y = v * ctx.canvas.height / 2;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                        x += sliceWidth;
                    }
                    ctx.stroke();
                    afId = requestAnimationFrame(draw);
                };
                draw();
                return () => cancelAnimationFrame(afId);
            }, [moduleId, audioEngine]);

            return <canvas ref={canvasRef} className="oscilloscope-display" width="180" height="80" />;
        }

        function Module({ data, def, selected, onMove, onChange, onJackMouseDown, extra }) {
            const [dragging, setDragging] = useState(false);
            const [offset, setOffset] = useState({ x: 0, y: 0 });
            const ref = useRef(null);

            const handleMouseDown = (e) => {
                e.stopPropagation();
                const rect = ref.current.getBoundingClientRect();
                setOffset({ x: e.clientX - rect.left, y: e.clientY - rect.top });
                setDragging(true);
            };

            useEffect(() => {
                const handleMouseMove = (e) => {
                    if (!dragging) return;
                    const parentRect = ref.current.parentElement.getBoundingClientRect();
                    const newX = e.clientX - parentRect.left - offset.x;
                    const newY = e.clientY - parentRect.top - offset.y;
                    onMove(data.id, newX, newY);
                };
                const handleMouseUp = () => setDragging(false);

                if (dragging) {
                    window.addEventListener('mousemove', handleMouseMove);
                    window.addEventListener('mouseup', handleMouseUp);
                }
                return () => {
                    window.removeEventListener('mousemove', handleMouseMove);
                    window.removeEventListener('mouseup', handleMouseUp);
                };
            }, [dragging, offset, data.id, onMove]);

            const handleControlChange = (ctrlId, val) => {
                onChange(data.id, ctrlId, val);
            };

            return (
                <div 
                    className="module" 
                    ref={ref}
                    style={{ 
                        left: data.x, 
                        top: data.y, 
                        width: def.width,
                        zIndex: dragging ? 100 : 10
                    }}
                >
                    <div className="module-header" onMouseDown={handleMouseDown}>
                        {def.name}
                    </div>
                    <div className="module-body">
                        {/* Custom Module Content */}
                        {data.type === 'sequencer' && extra && (
                            <SequencerDisplay 
                                stepValues={extra.stepValues} 
                                currentStep={extra.currentStep}
                                onStepToggle={extra.onStepToggle}
                            />
                        )}
                        {data.type === 'oscilloscope' && extra && (
                            <OscilloscopeDisplay moduleId={data.id} audioEngine={extra.audioEngine} />
                        )}

                        {/* Controls */}
                        <div className="controls-grid">
                            {def.controls.map(c => {
                                const current = data.controls.find(ctrl => ctrl.id === c.id);
                                const val = current ? current.value : c.default;
                                return c.type === 'switch' ? (
                                    <Switch 
                                        key={c.id} 
                                        label={c.name} 
                                        value={val} 
                                        onChange={(v) => handleControlChange(c.id, v)} 
                                    />
                                ) : (
                                    <Knob 
                                        key={c.id} 
                                        label={c.name} 
                                        value={val} 
                                        onChange={(v) => handleControlChange(c.id, v)} 
                                    />
                                );
                            })}
                        </div>

                        {/* IO */}
                        <div className="io-panel">
                            {def.inputs.map(input => (
                                <Jack 
                                    key={input.id} 
                                    id={`${data.id}-in-${input.id}`}
                                    label={input.name} 
                                    type="input"
                                    onMouseDown={onJackMouseDown}
                                />
                            ))}
                            <div style={{flex:1}}></div>
                            {def.outputs.map(output => (
                                <Jack 
                                    key={output.id} 
                                    id={`${data.id}-out-${output.id}`}
                                    label={output.name} 
                                    type="output"
                                    onMouseDown={onJackMouseDown}
                                />
                            ))}
                        </div>
                    </div>
                </div>
            );
        }

        function Cable({ fromId, toId, onRemove }) {
            const [path, setPath] = useState('');

            // Recalculate path on every frame/render to track moving modules
            useEffect(() => {
                const updatePath = () => {
                    const el1 = document.getElementById(fromId);
                    const el2 = document.getElementById(toId);
                    if (!el1 || !el2) return;

                    // Get centers relative to container
                    const r1 = el1.getBoundingClientRect();
                    const r2 = el2.getBoundingClientRect();
                    
                    // We need relative coords to the SVG container (which fills the rack)
                    // We assume the SVG is at 0,0 of the rack-area.
                    // We can use the parent rack-area BBox
                    const container = document.querySelector('.rack-area');
                    if (!container) return;
                    const cR = container.getBoundingClientRect();

                    const x1 = r1.left - cR.left + r1.width/2;
                    const y1 = r1.top - cR.top + r1.height/2;
                    const x2 = r2.left - cR.left + r2.width/2;
                    const y2 = r2.top - cR.top + r2.height/2;

                    const dx = Math.abs(x2 - x1);
                    const dy = Math.abs(y2 - y1);
                    const controlX = Math.max(dx * 0.5, 50);
                    const controlY = Math.max(dy * 0.5, 50);
                    
                    // Bezier curve with some gravity/slack look
                    // M x1 y1 C x1 y1+c, x2 y2+c, x2 y2
                    
                    setPath(`M ${x1} ${y1} C ${x1} ${y1 + controlY + 50}, ${x2} ${y2 + controlY + 50}, ${x2} ${y2}`);
                };
                
                // Use ResizeObserver or MutationObserver? 
                // Simpler: rAF loop for smooth updates during drag
                let frame;
                const loop = () => {
                    updatePath();
                    frame = requestAnimationFrame(loop);
                };
                loop();
                return () => cancelAnimationFrame(frame);
            }, [fromId, toId]);

            return (
                <path 
                    d={path} 
                    className="cable-path" 
                    stroke="var(--cable-color)" 
                    onClick={onRemove}
                />
            );
        }

        function App() {
            const [modules, setModules] = useState([]);
            const [cables, setCables] = useState([]);
            const [audio, setAudio] = useState(new AudioEngine());
            const [cableStart, setCableStart] = useState(null); // { id, type }
            const [sequencerStates, setSequencerStates] = useState({});
            const fileInputRef = useRef(null);

            const savePatch = () => {
                const patch = { modules, cables, sequencerStates };
                const blob = new Blob([JSON.stringify(patch)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'synth-patch.json';
                a.click();
            };

            const loadPatch = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (evt) => {
                    try {
                        const data = JSON.parse(evt.target.result);
                        if (data.modules && data.cables) {
                            // Re-create audio nodes
                            data.modules.forEach(m => audio.createModule(m));
                            
                            setModules(data.modules);
                            setCables(data.cables);
                            if (data.sequencerStates) setSequencerStates(data.sequencerStates);
                        }
                    } catch (err) {
                        alert('Failed to load patch');
                    }
                };
                reader.readAsText(file);
                e.target.value = ''; // Reset
            };

            // Init Audio
            useEffect(() => {
                const init = async () => {
                    await audio.init();
                    loadDefaultPatch();
                };
                // User gesture required for AudioContext usually
                const onClick = () => {
                    init();
                    document.removeEventListener('click', onClick);
                };
                document.addEventListener('click', onClick);
            }, []);

            // Audio Graph Sync
            useEffect(() => {
                // When cables change, update connections
                // Simplest strategy: Rebuild connections
                if (!audio.initialized) return;
                
                // We don't disconnect everything blindly to avoid glitches, 
                // but for this prototype, we just ensure connections exist.
                // Actually, the AudioEngine disconnectAll is aggressive. 
                // Let's just try to connect new ones.
                
                // BETTER: The AudioEngine should expose a method to 'sync' topology
                // or we just call connect() for every cable. WebAudio allows multi-connection.
                // Disconnecting specific old ones is hard without tracking.
                // Let's rely on disconnectAll() then reconnectAll() for correctness, 
                // accepting minor glitch on patching.
                
                audio.disconnectAll();
                
                // Reconnect internal
                modules.forEach(m => audio.updateModule(m));
                
                cables.forEach(c => {
                    // Parse IDs: "modId-type-portId"
                    // ex: "osc1-out-out", "filter1-in-in"
                    const parse = (str) => {
                        const parts = str.split('-');
                        // Structure: moduleId-[in/out]-portId
                        // But moduleId might contain dashes. 
                        // We generated jack IDs as `${data.id}-in-${input.id}`
                        // So we split by '-in-' or '-out-'
                        let modId, portId;
                        if (str.includes('-in-')) {
                            [modId, portId] = str.split('-in-');
                        } else {
                            [modId, portId] = str.split('-out-');
                        }
                        return { modId, portId };
                    };
                    
                    const src = parse(c.from);
                    const dst = parse(c.to);
                    
                    audio.connect(src.modId, src.portId, dst.modId, dst.portId);
                });
                
            }, [cables, audio.initialized]);

            // Module Parameter Sync
            useEffect(() => {
                if(!audio.initialized) return;
                modules.forEach(m => audio.updateModule(m));
            }, [modules, audio.initialized]);

            // Sequencer Logic Loop
            useEffect(() => {
                const interval = setInterval(() => {
                    // Iterate all sequencers
                    const now = audio.ctx ? audio.ctx.currentTime : 0;
                    
                    setSequencerStates(prev => {
                        const next = { ...prev };
                        let changed = false;

                        modules.filter(m => m.type === 'sequencer').forEach(seq => {
                            const state = next[seq.id] || { stepValues: [0,0,0,0], currentStep: 0, lastTime: 0 };
                            const runCtrl = seq.controls.find(c => c.id === 'run');
                            const isRunning = runCtrl ? runCtrl.value : 0;
                            
                            if (isRunning) {
                                const tempoCtrl = seq.controls.find(c => c.id === 'tempo');
                                const tempo = 60 + (tempoCtrl ? tempoCtrl.value : 0.5) * 180; // 60-240
                                const beatTime = 60 / tempo;
                                
                                if (now - state.lastTime >= beatTime) {
                                    state.currentStep = (state.currentStep + 1) % 4;
                                    state.lastTime = now;
                                    
                                    // Trigger output
                                    // Map step value (0 or 1) to CV?
                                    // Actually, let's make step buttons toggles for Gate, 
                                    // and maybe they have a value?
                                    // Simplified: Steps are ON/OFF (gate). CV is flat?
                                    // Or Steps have pitch? We only have buttons.
                                    // Let's assume buttons are Gate ON. CV is... random? or fixed?
                                    // Let's make buttons toggle Gate. CV = 0.
                                    // Wait, typical simple sequencers have knobs per step.
                                    // We simplified to buttons.
                                    // Let's say buttons are Gate. 
                                    // Audio Engine needs update.
                                    
                                    const gate = state.stepValues[state.currentStep] ? 1 : 0;
                                    audio.updateSequencer(seq.id, 0, gate);
                                    
                                    // Check connections to Envelopes (Logic Bridge)
                                    // Find cables from this sequencer Gate output to Envelopes
                                    cables.forEach(c => {
                                        if (c.from.includes(`${seq.id}-out-gate`)) {
                                            // Find dest
                                            if (c.to.includes('gate')) {
                                                // Trigger envelope
                                                const [destId] = c.to.split('-in-');
                                                audio.triggerEnvelope(destId, gate);
                                            }
                                        }
                                    });
                                    
                                    changed = true;
                                }
                            }
                            next[seq.id] = state;
                        });
                        
                        return changed ? next : prev;
                    });
                }, 50);
                return () => clearInterval(interval);
            }, [modules, cables, audio]);


            const addModule = (type, x = 100, y = 100) => {
                const def = MODULE_DEFINITIONS[type];
                const id = type + '_' + Date.now();
                
                const newMod = {
                    id,
                    type,
                    x, y,
                    controls: def.controls.map(c => ({ id: c.id, value: c.default }))
                };
                
                setModules(prev => [...prev, newMod]);
                audio.createModule(newMod);
            };

            const loadDefaultPatch = () => {
                // Clear existing
                setModules([]);
                setCables([]);
                
                // Create Basic Patch: Osc -> VCF -> VCA -> Out
                // Plus Envelope -> VCA
                
                // We need to wait for state update cycles or just build state object
                // Batching...
                
                const m1 = { id: 'osc1', type: 'oscillator', x: 50, y: 50, controls: [{id:'freq', value:0.3}, {id:'wave', value:0.5}] };
                const m2 = { id: 'filter1', type: 'vcf', x: 250, y: 50, controls: [{id:'cutoff', value:0.5}, {id:'res', value:0.2}] };
                const m3 = { id: 'vca1', type: 'vca', x: 450, y: 50, controls: [{id:'level', value:0.0}] };
                const m4 = { id: 'out1', type: 'output', x: 650, y: 100, controls: [{id:'vol', value:0.8}] };
                const m5 = { id: 'env1', type: 'envelope', x: 450, y: 250, controls: [{id:'a', value:0.01}, {id:'d', value:0.2}, {id:'s', value:0.5}, {id:'r', value:0.5}] };
                const m6 = { id: 'seq1', type: 'sequencer', x: 50, y: 250, controls: [{id:'tempo', value:0.5}, {id:'run', value:1}] };
                
                // Register in Audio Engine
                [m1,m2,m3,m4,m5,m6].forEach(m => audio.createModule(m));
                
                setModules([m1,m2,m3,m4,m5,m6]);
                setSequencerStates({
                    'seq1': { stepValues: [1,0,1,0], currentStep: 0, lastTime: 0 }
                });

                // Connections
                const c1 = { from: 'osc1-out-out', to: 'filter1-in-in', id: 'c1' };
                const c2 = { from: 'filter1-out-out', to: 'vca1-in-in', id: 'c2' };
                const c3 = { from: 'vca1-out-out', to: 'out1-in-in', id: 'c3' };
                const c4 = { from: 'env1-out-out', to: 'vca1-in-cv', id: 'c4' };
                const c5 = { from: 'seq1-out-gate', to: 'env1-in-gate', id: 'c5' };
                
                setCables([c1, c2, c3, c4, c5]);
            };

            const handleMove = (id, x, y) => {
                setModules(prev => prev.map(m => m.id === id ? { ...m, x, y } : m));
            };

            const handleChange = (modId, ctrlId, val) => {
                setModules(prev => prev.map(m => {
                    if (m.id !== modId) return m;
                    const newCtrls = m.controls.map(c => c.id === ctrlId ? { ...c, value: val } : c);
                    return { ...m, controls: newCtrls };
                }));
            };

            const handleJackDown = (id, type) => {
                if (!cableStart) {
                    setCableStart({ id, type });
                } else {
                    if (cableStart.id === id) {
                        setCableStart(null); // Cancel
                        return;
                    }
                    if (cableStart.type === type) {
                        // Can't connect input to input
                        setCableStart({ id, type }); // Switch start point
                        return;
                    }
                    
                    // Create Connection
                    const from = cableStart.type === 'output' ? cableStart.id : id;
                    const to = cableStart.type === 'input' ? cableStart.id : id;
                    
                    setCables(prev => [...prev, { from, to, id: Date.now() }]);
                    setCableStart(null);
                }
            };
            
            const handleSequencerStep = (seqId, idx) => {
                setSequencerStates(prev => {
                    const st = prev[seqId] || { stepValues: [0,0,0,0], currentStep:0 };
                    const newVals = [...st.stepValues];
                    newVals[idx] = newVals[idx] ? 0 : 1;
                    return { ...prev, [seqId]: { ...st, stepValues: newVals } };
                });
            };

            // Drag from sidebar
            const handleDragStart = (e, type) => {
                e.dataTransfer.setData('type', type);
            };
            
            const handleDrop = (e) => {
                e.preventDefault();
                const type = e.dataTransfer.getData('type');
                if (type) {
                    const rect = e.currentTarget.getBoundingClientRect();
                    addModule(type, e.clientX - rect.left, e.clientY - rect.top);
                }
            };

            return (
                <div className="container">
                    <div className="module-panel">
                        <h2>Modules</h2>
                        {Object.entries(MODULE_DEFINITIONS).map(([key, def]) => (
                            <div 
                                key={key} 
                                className="module-item" 
                                draggable 
                                onDragStart={(e) => handleDragStart(e, key)}
                            >
                                {def.name}
                            </div>
                        ))}
                    </div>
                    
                    <div className="rack">
                        <div className="rack-header">
                            <h2>Rack</h2>
                            <div className="controls">
                                <button className="btn" onClick={savePatch}>Save</button>
                                <button className="btn" onClick={() => fileInputRef.current.click()}>Load</button>
                                <input 
                                    type="file" 
                                    ref={fileInputRef} 
                                    style={{display:'none'}} 
                                    accept=".json" 
                                    onChange={loadPatch} 
                                />
                                <button className="btn" onClick={() => { setModules([]); setCables([]); }}>Clear</button>
                                <button className="btn" onClick={loadDefaultPatch}>Reset to Default</button>
                                <div style={{color:'#666', fontSize:'0.8rem', display:'flex', alignItems:'center', marginLeft:'10px'}}>
                                    {cableStart ? 'Select destination...' : 'Click jack to patch'}
                                </div>
                            </div>
                        </div>
                        
                        <div className="rack-area" onDragOver={e => e.preventDefault()} onDrop={handleDrop}>
                            <svg className="cables-layer">
                                {cables.map(c => (
                                    <Cable 
                                        key={c.id} 
                                        fromId={c.from} 
                                        toId={c.to} 
                                        onRemove={() => setCables(prev => prev.filter(x => x.id !== c.id))} 
                                    />
                                ))}
                                {cableStart && (
                                    // Visual line for pending connection could go here
                                    // For now, simpler UI is fine
                                    null
                                )}
                            </svg>
                            
                            {modules.map(m => (
                                <Module 
                                    key={m.id} 
                                    data={m} 
                                    def={MODULE_DEFINITIONS[m.type]} 
                                    onMove={handleMove}
                                    onChange={handleChange}
                                    onJackMouseDown={handleJackDown}
                                    extra={
                                        m.type === 'sequencer' ? { 
                                            stepValues: (sequencerStates[m.id] || {stepValues:[0,0,0,0]}).stepValues,
                                            currentStep: (sequencerStates[m.id] || {}).currentStep,
                                            onStepToggle: (idx) => handleSequencerStep(m.id, idx)
                                        } : m.type === 'oscilloscope' ? {
                                            audioEngine: audio
                                        } : null
                                    }
                                />
                            ))}
                        </div>
                    </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>