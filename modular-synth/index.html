<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Modular Synth Prototype</title>
    <style>
body {
    font-family: Arial, sans-serif;
    margin: 0;
    padding: 0;
    background-color: #222;
    color: #fff;
}

.container {
    display: flex;
    height: 100vh;
}

.module-panel {
    width: 200px;
    background-color: #333;
    padding: 20px;
    box-sizing: border-box;
}

.module-panel h2 {
    margin-top: 0;
}

.module-item {
    background-color: #444;
    padding: 10px;
    margin-bottom: 10px;
    cursor: grab;
    border-radius: 5px;
    text-align: center;
}

.module-item:hover {
    background-color: #555;
}

.rack {
    flex: 1;
    background-color: #111;
    padding: 20px;
    box-sizing: border-box;
    position: relative;
}

.rack h2 {
    margin-top: 0;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.controls {
    display: flex;
    gap: 10px;
}

.save-btn, .load-btn {
    background-color: #444;
    color: #fff;
    border: 1px solid #666;
    padding: 8px 16px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 14px;
}

.save-btn:hover, .load-btn:hover {
    background-color: #555;
}

.load-btn {
    position: relative;
}

.load-input {
    position: absolute;
    left: 0;
    top: 0;
    opacity: 0;
    width: 100%;
    height: 100%;
    cursor: pointer;
}

.rack-area {
    height: calc(100% - 40px);
    background-color: #000;
    border: 1px solid #444;
    position: relative;
    overflow: hidden;
}

.module {
    position: absolute;
    background-color: #333;
    border: 1px solid #666;
    border-radius: 5px;
    padding: 10px;
    min-width: 120px;
    min-height: 100px;
    cursor: move;
}

.module-header {
    background-color: #444;
    padding: 5px;
    margin: -10px -10px 10px -10px;
    border-radius: 5px 5px 0 0;
    cursor: move;
}

.patch-point {
    position: absolute;
    width: 10px;
    height: 10px;
    background-color: #888;
    border-radius: 50%;
    cursor: pointer;
}

.patch-point:hover {
    background-color: #aaa;
}

.patch-point.active {
    background-color: #ff0;
    box-shadow: 0 0 10px #ff0;
}

.connection {
    position: absolute;
    pointer-events: none;
    stroke: #0f0;
    stroke-width: 2;
    fill: none;
}

.potentiometer {
    width: 45px;
    height: 45px;
    background-color: #666;
    border-radius: 50%;
    margin: 2px;
    cursor: pointer;
    position: relative;
    border: 2px solid #888;
}

.potentiometer input[type="range"] {
    -webkit-appearance: none;
    appearance: none;
    width: 100%;
    height: 6px;
    background: #444;
    outline: none;
    border-radius: 3px;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
}

.potentiometer input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 18px;
    height: 18px;
    background: #fff;
    border-radius: 50%;
    cursor: pointer;
    border: 2px solid #ccc;
}

.potentiometer input[type="range"]::-moz-range-thumb {
    width: 18px;
    height: 18px;
    background: #fff;
    border-radius: 50%;
    cursor: pointer;
    border: 2px solid #ccc;
}

.switch {
    width: 50px;
    height: 25px;
    background-color: #666;
    border-radius: 12px;
    margin: 2px;
    cursor: pointer;
    position: relative;
    border: 2px solid #888;
}

.switch input {
    opacity: 0;
    width: 100%;
    height: 100%;
    position: absolute;
    top: 0;
    left: 0;
    margin: 0;
    cursor: pointer;
}

.slider {
    position: absolute;
    top: 2px;
    left: 2px;
    width: 19px;
    height: 19px;
    background-color: #fff;
    border-radius: 50%;
    transition: left 0.2s;
    border: 1px solid #ccc;
}

.switch input:checked + .slider {
    left: 27px;
}
    </style>
    <!-- React from CDN -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
/**
 * @typedef {Object} PatchPoint
 * @property {string} id - Unique identifier for the patch point
 * @property {string} name - Display name of the patch point
 * @property {'input'|'output'} type - Whether this is an input or output
 * @property {number} x - X position relative to module
 * @property {number} y - Y position relative to module
 */

/**
 * @typedef {Object} Control
 * @property {string} id - Unique identifier for the control
 * @property {string} name - Display name of the control
 * @property {'potentiometer'|'switch'} type - Type of control
 * @property {number} value - Current value (0-1 for potentiometers, 0/1 for switches)
 * @property {number} x - X position relative to module
 * @property {number} y - Y position relative to module
 */

/**
 * @typedef {Object} Module
 * @property {string} id - Unique identifier
 * @property {string} type - Module type (oscillator, vcf, etc.)
 * @property {string} name - Display name
 * @property {number} x - X position on rack
 * @property {number} y - Y position on rack
 * @property {number} width - Module width
 * @property {number} height - Module height
 * @property {PatchPoint[]} patchPoints - Array of patch points
 * @property {Control[]} controls - Array of controls
 */

/**
 * @typedef {Object} Connection
 * @property {string} id - Unique identifier
 * @property {string} fromModuleId - ID of source module
 * @property {string} fromPatchId - ID of source patch point
 * @property {string} toModuleId - ID of destination module
 * @property {string} toPatchId - ID of destination patch point
 */

/**
 * Creates a module definition with JSDoc types
 * @param {string} type - Module type
 * @param {string} name - Display name
 * @param {number} width - Module width
 * @param {number} height - Module height
 * @param {PatchPoint[]} patchPoints - Patch points array
 * @param {Control[]} controls - Controls array
 * @returns {Omit<Module, 'id' | 'x' | 'y'>} Module template
 */
function createModuleTemplate(type, name, width, height, patchPoints, controls) {
    return {
        type,
        name,
        width,
        height,
        patchPoints: patchPoints.map((point, index) => ({
            ...point,
            id: `${type}-patch-${index}`
        })),
        controls: controls.map((control, index) => ({
            ...control,
            id: `${type}-control-${index}`,
            value: control.type === 'switch' ? 0 : 0.5
        }))
    };
}

// Module templates
const MODULE_TEMPLATES = {
    oscillator: createModuleTemplate(
        'oscillator',
        'Oscillator',
        160,
        120,
        [
            { name: 'V/Oct', type: 'input', x: -5, y: 40 },
            { name: 'Out', type: 'output', x: 155, y: 60 }
        ],
        [
            { name: 'Frequency', type: 'potentiometer', x: 30, y: 40 },
            { name: 'Waveform', type: 'potentiometer', x: 90, y: 40 }
        ]
    ),

    vcf: createModuleTemplate(
        'vcf',
        'VCF',
        140,
        140,
        [
            { name: 'In', type: 'input', x: -5, y: 40 },
            { name: 'Cutoff Mod', type: 'input', x: -5, y: 80 },
            { name: 'Out', type: 'output', x: 135, y: 60 }
        ],
        [
            { name: 'Cutoff', type: 'potentiometer', x: 20, y: 40 },
            { name: 'Resonance', type: 'potentiometer', x: 80, y: 40 }
        ]
    ),

    vca: createModuleTemplate(
        'vca',
        'VCA',
        140,
        120,
        [
            { name: 'Audio In', type: 'input', x: -5, y: 40 },
            { name: 'CV In', type: 'input', x: -5, y: 80 },
            { name: 'Out', type: 'output', x: 135, y: 60 }
        ],
        [
            { name: 'Level', type: 'potentiometer', x: 50, y: 40 }
        ]
    ),

    envelope: createModuleTemplate(
        'envelope',
        'Envelope',
        140,
        160,
        [
            { name: 'Gate', type: 'input', x: -5, y: 80 },
            { name: 'Out', type: 'output', x: 135, y: 80 }
        ],
        [
            { name: 'Attack', type: 'potentiometer', x: 20, y: 40 },
            { name: 'Decay', type: 'potentiometer', x: 80, y: 40 },
            { name: 'Sustain', type: 'potentiometer', x: 20, y: 80 },
            { name: 'Release', type: 'potentiometer', x: 80, y: 80 }
        ]
    ),

    'cv-gate': createModuleTemplate(
        'cv-gate',
        'CV/Gate Generator',
        140,
        120,
        [
            { name: 'CV Out', type: 'output', x: 135, y: 40 },
            { name: 'Gate Out', type: 'output', x: 135, y: 80 }
        ],
        [
            { name: 'CV Level', type: 'potentiometer', x: 20, y: 40 },
            { name: 'Gate', type: 'switch', x: 80, y: 40 }
        ]
    ),

    output: createModuleTemplate(
        'output',
        'Output',
        140,
        120,
        [
            { name: 'Audio In', type: 'input', x: -5, y: 60 }
        ],
        [
            { name: 'Volume', type: 'potentiometer', x: 50, y: 40 }
        ]
    ),

    mixer: createModuleTemplate(
        'mixer',
        'Mixer',
        200,
        180,
        [
            { name: 'In 1', type: 'input', x: -5, y: 35 },
            { name: 'In 2', type: 'input', x: -5, y: 65 },
            { name: 'In 3', type: 'input', x: -5, y: 95 },
            { name: 'In 4', type: 'input', x: -5, y: 125 },
            { name: 'Out', type: 'output', x: 195, y: 80 }
        ],
        [
            { name: 'Level 1', type: 'potentiometer', x: 30, y: 25 },
            { name: 'Level 2', type: 'potentiometer', x: 30, y: 55 },
            { name: 'Level 3', type: 'potentiometer', x: 30, y: 85 },
            { name: 'Level 4', type: 'potentiometer', x: 30, y: 115 },
            { name: 'Master', type: 'potentiometer', x: 130, y: 70 }
        ]
    ),

    sequencer: createModuleTemplate(
        'sequencer',
        'Sequencer',
        220,
        160,
        [
            { name: 'CV Out', type: 'output', x: 215, y: 60 },
            { name: 'Gate Out', type: 'output', x: 215, y: 100 }
        ],
        [
            { name: 'Tempo', type: 'potentiometer', x: 20, y: 30 },
            { name: 'Play/Stop', type: 'switch', x: 100, y: 30 }
        ]
    ),

    oscilloscope: createModuleTemplate(
        'oscilloscope',
        'Oscilloscope',
        200,
        140,
        [
            { name: 'In', type: 'input', x: -5, y: 70 }
        ],
        [
            { name: 'Timebase', type: 'potentiometer', x: 20, y: 20 },
            { name: 'Vertical', type: 'potentiometer', x: 80, y: 20 },
            { name: 'Trigger', type: 'potentiometer', x: 140, y: 20 }
        ]
    ),

    lfo: createModuleTemplate(
        'lfo',
        'LFO',
        140,
        120,
        [
            { name: 'Out', type: 'output', x: 135, y: 60 }
        ],
        [
            { name: 'Frequency', type: 'potentiometer', x: 20, y: 40 },
            { name: 'Amplitude', type: 'potentiometer', x: 80, y: 40 }
        ]
    ),

    'level-meter': createModuleTemplate(
        'level-meter',
        'Level Meter',
        120,
        140,
        [
            { name: 'In', type: 'input', x: -5, y: 70 }
        ],
        []
    ),

    gate: createModuleTemplate(
        'gate',
        'Gate',
        120,
        100,
        [
            { name: 'Out', type: 'output', x: 115, y: 50 }
        ],
        [
            { name: 'Gate', type: 'switch', x: 50, y: 40 }
        ]
    )
};

/**
 * Creates a new module instance
 * @param {string} type - Module type
 * @param {number} x - X position
 * @param {number} y - Y position
 * @returns {Module} New module instance
 */
function createModule(type, x, y) {
    const template = MODULE_TEMPLATES[type];
    if (!template) {
        throw new Error(`Unknown module type: ${type}`);
    }

    const moduleId = `${type}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;

    return {
        id: moduleId,
        ...template,
        patchPoints: template.patchPoints.map((point, index) => ({
            ...point,
            id: `${moduleId}-patch-${index}`
        })),
        controls: template.controls.map((control, index) => ({
            ...control,
            id: `${moduleId}-control-${index}`
        })),
        x,
        y
    };
}

/**
 * Creates a new connection
 * @param {string} fromModuleId - Source module ID
 * @param {string} fromPatchId - Source patch point ID
 * @param {string} toModuleId - Destination module ID
 * @param {string} toPatchId - Destination patch point ID
 * @returns {Connection} New connection
 */
function createConnection(fromModuleId, fromPatchId, toModuleId, toPatchId) {
    return {
        id: `connection-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
        fromModuleId,
        fromPatchId,
        toModuleId,
        toPatchId
    };
}

/**
 * Audio Engine - Manages Web Audio API nodes and connections
 */
class AudioEngine {
    constructor() {
        this.audioContext = null;
        this.audioNodes = new Map();
        this.gainNodes = new Map();
        this.initialized = false;
    }

    /**
     * Initialize the audio context
     */
    async init() {
        if (this.initialized) return;

        try {
            this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            this.initialized = true;
        } catch (error) {
            console.error('Failed to initialize audio context:', error);
        }
    }

    /**
     * Create audio node for a module
     * @param {Module} module - Module data
     * @returns {AudioNode|null} Created audio node
     */
    createAudioNode(module) {
        if (!this.audioContext) return null;

        switch (module.type) {
            case 'oscillator':
                const oscillator = this.audioContext.createOscillator();
                const oscGain = this.audioContext.createGain();
                const vOctGain = this.audioContext.createGain();

                oscillator.frequency.value = 440; // Default frequency
                oscillator.type = 'sine';
                oscGain.gain.value = 0.1; // Low volume to prevent clipping
                vOctGain.gain.value = 1; // Default multiplier

                oscillator.connect(oscGain);
                vOctGain.connect(oscillator.frequency);
                oscillator.start();

                this.audioNodes.set(module.id, oscillator);
                this.gainNodes.set(module.id, oscGain);
                this.gainNodes.set(`${module.id}-v-oct`, vOctGain);

                return oscGain;

            case 'output':
                const outputGain = this.audioContext.createGain();
                outputGain.gain.value = 0.5; // Default volume
                outputGain.connect(this.audioContext.destination);

                this.gainNodes.set(module.id, outputGain);
                return outputGain;

            case 'vca':
                const vcaGain = this.audioContext.createGain();
                vcaGain.gain.value = 0;

                // Create CV input gain node for modulation
                const vcaCvGain = this.audioContext.createGain();
                vcaCvGain.gain.value = 0;

                this.gainNodes.set(module.id, vcaGain);
                this.gainNodes.set(`${module.id}-cv`, vcaCvGain);

                // Connect CV input to modulate the main gain
                vcaCvGain.connect(vcaGain.gain);

                return vcaGain;

            case 'vcf':
                const filter = this.audioContext.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 1000;
                filter.Q.value = 1;

                this.audioNodes.set(module.id, filter);
                return filter;

            case 'mixer':
                // Create mixer with four input channels and master output
                const mixerInput1 = this.audioContext.createGain();
                const mixerInput2 = this.audioContext.createGain();
                const mixerInput3 = this.audioContext.createGain();
                const mixerInput4 = this.audioContext.createGain();
                const mixerMaster = this.audioContext.createGain();

                mixerInput1.gain.value = 0.5; // Default level 1
                mixerInput2.gain.value = 0.5; // Default level 2
                mixerInput3.gain.value = 0.5; // Default level 3
                mixerInput4.gain.value = 0.5; // Default level 4
                mixerMaster.gain.value = 0.5; // Default master

                mixerInput1.connect(mixerMaster);
                mixerInput2.connect(mixerMaster);
                mixerInput3.connect(mixerMaster);
                mixerInput4.connect(mixerMaster);

                // Store references for updating
                this.audioNodes.set(`${module.id}-input1`, mixerInput1);
                this.audioNodes.set(`${module.id}-input2`, mixerInput2);
                this.audioNodes.set(`${module.id}-input3`, mixerInput3);
                this.audioNodes.set(`${module.id}-input4`, mixerInput4);
                this.gainNodes.set(module.id, mixerMaster);

                return mixerMaster;

            case 'envelope':
                // Simple envelope generator using gain node
                const envGain = this.audioContext.createGain();
                envGain.gain.value = 0;

                this.gainNodes.set(module.id, envGain);
                return envGain;

            case 'oscilloscope':
                // Oscilloscope needs a gain node to receive input signals and an analyser for visualization
                const scopeGain = this.audioContext.createGain();
                scopeGain.gain.value = 1; // Unity gain for monitoring

                const analyser = this.audioContext.createAnalyser();
                analyser.fftSize = 2048;
                analyser.smoothingTimeConstant = 0.8;

                // Connect gain to analyser
                scopeGain.connect(analyser);

                this.gainNodes.set(module.id, scopeGain);
                this.audioNodes.set(module.id, analyser); // Store analyser for access by component
                return scopeGain;

            case 'lfo':
                // LFO (Low Frequency Oscillator) - creates modulation signals
                const lfoOscillator = this.audioContext.createOscillator();
                const lfoGain = this.audioContext.createGain();

                lfoOscillator.frequency.value = 1; // Default 1 Hz
                lfoOscillator.type = 'sine';
                lfoGain.gain.value = 0.5; // Default amplitude

                lfoOscillator.connect(lfoGain);
                lfoOscillator.start();

                this.audioNodes.set(module.id, lfoOscillator);
                this.gainNodes.set(module.id, lfoGain);
                return lfoGain;

            case 'level-meter':
                // Level Meter - needs a gain node to receive input signals and an analyser for level monitoring
                const levelGain = this.audioContext.createGain();
                levelGain.gain.value = 1; // Unity gain for monitoring

                const levelAnalyser = this.audioContext.createAnalyser();
                levelAnalyser.fftSize = 2048;
                levelAnalyser.smoothingTimeConstant = 0.8;

                // Connect gain to analyser
                levelGain.connect(levelAnalyser);

                this.gainNodes.set(module.id, levelGain);
                this.audioNodes.set(module.id, levelAnalyser); // Store analyser for access by component
                return levelGain;

            case 'gate':
                // Gate - simple toggle that outputs 1.0 (high) or 0.0 (low)
                const gateGain = this.audioContext.createGain();
                gateGain.gain.value = 0; // Default to off (0)

                this.gainNodes.set(module.id, gateGain);
                return gateGain;

            default:
                // Generic gain node for other modules
                const gain = this.audioContext.createGain();
                this.gainNodes.set(module.id, gain);
                return gain;
        }
    }

    /**
     * Update audio node parameters based on module controls
     * @param {Module} module - Module data
     */
    updateModule(module) {
        if (!this.audioContext) return;

        const audioNode = this.audioNodes.get(module.id);
        const gainNode = this.gainNodes.get(module.id);

        switch (module.type) {
            case 'oscillator':
                if (audioNode) {
                    const freqControl = module.controls.find(c => c.name === 'Frequency');
                    if (freqControl) {
                        // Map 0-1 to 20-2000 Hz
                        audioNode.frequency.value = 20 + (freqControl.value * 1980);
                    }

                    const waveformControl = module.controls.find(c => c.name === 'Waveform');
                    if (waveformControl) {
                        // Map 0-1 range to sine -> square -> sawtooth
                        if (waveformControl.value < 0.33) {
                            audioNode.type = 'sine';
                        } else if (waveformControl.value < 0.66) {
                            audioNode.type = 'square';
                        } else {
                            audioNode.type = 'sawtooth';
                        }
                    }

                    // Handle V/Oct input modulation
                    const vOctGain = this.gainNodes.get(`${module.id}-v-oct`);
                    if (vOctGain) {
                        // V/Oct standard: 1V per octave, so 1V = 2x frequency
                        // Map 0-1 to appropriate frequency multiplier
                        vOctGain.gain.value = Math.pow(2, (freqControl ? freqControl.value * 5 : 2.5) - 2.5);
                    }
                }
                break;

            case 'output':
                if (gainNode) {
                    const volumeControl = module.controls.find(c => c.name === 'Volume');
                    if (volumeControl) {
                        gainNode.gain.value = volumeControl.value;
                    }
                }
                break;

            case 'vcf':
                if (audioNode) {
                    const cutoffControl = module.controls.find(c => c.name === 'Cutoff');
                    if (cutoffControl) {
                        // Map 0-1 to 20-20000 Hz
                        audioNode.frequency.value = 20 + (cutoffControl.value * 19980);
                    }

                    const resonanceControl = module.controls.find(c => c.name === 'Resonance');
                    if (resonanceControl) {
                        audioNode.Q.value = 0.1 + (resonanceControl.value * 20);
                    }
                }
                break;

            case 'vca':
                if (gainNode) {
                    const levelControl = module.controls.find(c => c.name === 'Level');
                    if (levelControl) {
                        gainNode.gain.value = levelControl.value;
                    }
                }
                // CV input modulation is handled via the gain connection in createAudioNode
                break;

            case 'mixer':
                // Update mixer input levels and master
                const mixerInput1 = this.audioNodes.get(`${module.id}-input1`);
                const mixerInput2 = this.audioNodes.get(`${module.id}-input2`);
                const mixerInput3 = this.audioNodes.get(`${module.id}-input3`);
                const mixerInput4 = this.audioNodes.get(`${module.id}-input4`);
                const mixerMaster = this.gainNodes.get(module.id);

                const level1Control = module.controls.find(c => c.name === 'Level 1');
                const level2Control = module.controls.find(c => c.name === 'Level 2');
                const level3Control = module.controls.find(c => c.name === 'Level 3');
                const level4Control = module.controls.find(c => c.name === 'Level 4');
                const masterControl = module.controls.find(c => c.name === 'Master');

                if (mixerInput1 && level1Control) {
                    mixerInput1.gain.value = level1Control.value;
                }
                if (mixerInput2 && level2Control) {
                    mixerInput2.gain.value = level2Control.value;
                }
                if (mixerInput3 && level3Control) {
                    mixerInput3.gain.value = level3Control.value;
                }
                if (mixerInput4 && level4Control) {
                    mixerInput4.gain.value = level4Control.value;
                }
                if (mixerMaster && masterControl) {
                    mixerMaster.gain.value = masterControl.value;
                }
                break;

            case 'lfo':
                if (audioNode) {
                    const freqControl = module.controls.find(c => c.name === 'Frequency');
                    if (freqControl) {
                        // Map 0-1 to 0.1-20 Hz (LFO range)
                        audioNode.frequency.value = 0.1 + (freqControl.value * 19.9);
                    }
                }
                if (gainNode) {
                    const ampControl = module.controls.find(c => c.name === 'Amplitude');
                    if (ampControl) {
                        gainNode.gain.value = ampControl.value;
                    }
                }
                break;

            case 'gate':
                if (gainNode) {
                    const gateControl = module.controls.find(c => c.name === 'Gate');
                    if (gateControl) {
                        // Output 1.0 for gate on, 0.0 for gate off
                        gainNode.gain.value = gateControl.value;
                    }
                }
                break;
        }
    }

    /**
     * Connect audio nodes based on connections
     * @param {Module[]} modules - All modules
     * @param {Connection[]} connections - All connections
     */
    updateConnections(modules, connections) {
        if (!this.audioContext) return;

        // First, disconnect ALL gain nodes from everything except their internal connections
        this.gainNodes.forEach((node, moduleId) => {
            try {
                // Disconnect from all destinations
                node.disconnect();
            } catch (e) {
                // Ignore disconnect errors
            }
        });

        // Reconnect internal oscillator connections (oscillator -> gain)
        this.audioNodes.forEach((node, moduleId) => {
            const module = modules.find(m => m.id === moduleId);
            if (module && module.type === 'oscillator') {
                try {
                    const gainNode = this.gainNodes.get(moduleId);
                    if (gainNode) {
                        node.connect(gainNode);
                    }
                } catch (e) {
                    // Ignore errors
                }
            }
        });

        // Now reconnect based on current connections
        connections.forEach(connection => {
            const fromModule = modules.find(m => m.id === connection.fromModuleId);
            const toModule = modules.find(m => m.id === connection.toModuleId);

            if (!fromModule || !toModule) return;

            // For source modules, use the gain node (output of the module)
            let fromNode = null;
            if (fromModule.type === 'oscillator') {
                fromNode = this.gainNodes.get(fromModule.id); // Use gain node for oscillator
            } else if (fromModule.type === 'sequencer') {
                // For sequencer, route to the correct output based on patch point
                const fromPatchPoint = fromModule.patchPoints.find(p => p.id === connection.fromPatchId);
                if (fromPatchPoint) {
                    if (fromPatchPoint.name === 'CV Out') {
                        fromNode = this.gainNodes.get(`${fromModule.id}-cv`);
                    } else if (fromPatchPoint.name === 'Gate Out') {
                        fromNode = this.gainNodes.get(`${fromModule.id}-gate`);
                    }
                }
                // Fallback to main gain node if patch point not found
                if (!fromNode) {
                    fromNode = this.gainNodes.get(fromModule.id);
                }
            } else if (fromModule.type === 'gate') {
                // For gate module, use the main gain node
                fromNode = this.gainNodes.get(fromModule.id);
            } else {
                fromNode = this.audioNodes.get(fromModule.id) || this.gainNodes.get(fromModule.id);
            }

            // For destination modules, use the appropriate input node
            let toNode = null;
            if (toModule.type === 'output') {
                toNode = this.gainNodes.get(toModule.id); // Output module's gain node
            } else if (toModule.type === 'oscillator') {
                // For oscillator, route to the correct input
                const toPatchPoint = toModule.patchPoints.find(p => p.id === connection.toPatchId);
                if (toPatchPoint) {
                    if (toPatchPoint.name === 'V/Oct') {
                        toNode = this.gainNodes.get(`${toModule.id}-v-oct`);
                    }
                }
                // Fallback to main gain node if patch point not found
                if (!toNode) {
                    toNode = this.gainNodes.get(toModule.id);
                }
            } else if (toModule.type === 'vca') {
                // For VCA, route to the correct input
                const toPatchPoint = toModule.patchPoints.find(p => p.id === connection.toPatchId);
                if (toPatchPoint) {
                    if (toPatchPoint.name === 'CV In') {
                        toNode = this.gainNodes.get(`${toModule.id}-cv`);
                    } else if (toPatchPoint.name === 'Audio In') {
                        toNode = this.gainNodes.get(toModule.id);
                    }
                }
                // Fallback to main gain node if patch point not found
                if (!toNode) {
                    toNode = this.gainNodes.get(toModule.id);
                }
            } else if (toModule.type === 'mixer') {
                // For mixer, route to the correct input channel
                const toPatchPoint = toModule.patchPoints.find(p => p.id === connection.toPatchId);
                if (toPatchPoint) {
                    if (toPatchPoint.name === 'In 1') {
                        toNode = this.audioNodes.get(`${toModule.id}-input1`);
                    } else if (toPatchPoint.name === 'In 2') {
                        toNode = this.audioNodes.get(`${toModule.id}-input2`);
                    } else if (toPatchPoint.name === 'In 3') {
                        toNode = this.audioNodes.get(`${toModule.id}-input3`);
                    } else if (toPatchPoint.name === 'In 4') {
                        toNode = this.audioNodes.get(`${toModule.id}-input4`);
                    }
                }
                // Fallback to master if patch point not found
                if (!toNode) {
                    toNode = this.gainNodes.get(toModule.id);
                }
            } else if (toModule.type === 'level-meter') {
                // For level meter, route to the gain node (which feeds into analyser)
                toNode = this.gainNodes.get(toModule.id);
            } else {
                toNode = this.audioNodes.get(toModule.id) || this.gainNodes.get(toModule.id);
            }

            if (fromNode && toNode) {
                try {
                    fromNode.connect(toNode);
                } catch (error) {
                    console.error('Failed to connect audio nodes:', error);
                }
            }
        });

        // Ensure output modules are connected to destination only if they have input connections
        modules.forEach(module => {
            if (module.type === 'output') {
                const outputNode = this.gainNodes.get(module.id);
                if (outputNode) {
                    // Check if this output module has any input connections
                    const hasInputConnection = connections.some(conn => conn.toModuleId === module.id);
                    if (hasInputConnection) {
                        try {
                            outputNode.connect(this.audioContext.destination);
                        } catch (error) {
                            console.error('Failed to connect output to destination:', error);
                        }
                    }
                }
            }
        });
    }

    /**
     * Remove audio node for a module
     * @param {string} moduleId - Module ID
     */
    removeModule(moduleId) {
        const audioNode = this.audioNodes.get(moduleId);
        const gainNode = this.gainNodes.get(moduleId);

        if (audioNode) {
            try {
                audioNode.disconnect();
                if (audioNode.stop) audioNode.stop();
            } catch (e) {
                // Ignore errors
            }
            this.audioNodes.delete(moduleId);
        }

        if (gainNode) {
            try {
                gainNode.disconnect();
            } catch (e) {
                // Ignore errors
            }
            this.gainNodes.delete(moduleId);
        }
    }
}

const { useState, useRef, useCallback } = React;

/**
 * ModulePanel Component - Shows available modules to drag
 * @param {Object} props
 * @param {function} props.onDragStart - Called when dragging starts
 */
function ModulePanel({ onDragStart }) {
    const availableModules = [
        { type: 'oscillator', name: 'Oscillator' },
        { type: 'vcf', name: 'VCF' },
        { type: 'vca', name: 'VCA' },
        { type: 'envelope', name: 'Envelope' },
        { type: 'cv-gate', name: 'CV/Gate Generator' },
        { type: 'mixer', name: 'Mixer' },
        { type: 'sequencer', name: 'Sequencer' },
        { type: 'oscilloscope', name: 'Oscilloscope' },
        { type: 'level-meter', name: 'Level Meter' },
        { type: 'gate', name: 'Gate' },
        { type: 'lfo', name: 'LFO' },
        { type: 'output', name: 'Output' }
    ];

    return (
        <div className="module-panel">
            <h2>Modules</h2>
            {availableModules.map(module => (
                <div
                    key={module.type}
                    className="module-item"
                    draggable
                    onDragStart={(e) => onDragStart(e, module.type)}
                >
                    {module.name}
                </div>
            ))}
        </div>
    );
}

/**
 * PatchPoint Component - Individual connection point on modules
 * @param {Object} props
 * @param {import('./modules.js').PatchPoint} props.patchPoint - Patch point data
 * @param {function} props.onMouseDown - Called when mouse down on patch point
 * @param {boolean} props.isConnecting - Whether currently connecting
 * @param {string|null} props.connectionStartId - ID of connection start point
 */
function PatchPoint({ patchPoint, onMouseDown, isConnecting, connectionStartId }) {
    const handleMouseDown = useCallback((e) => {
        e.stopPropagation();
        onMouseDown(patchPoint.id);
    }, [patchPoint.id, onMouseDown]);

    const isActive = isConnecting && connectionStartId === patchPoint.id;

    return (
        <div
            className={`patch-point ${patchPoint.type} ${isActive ? 'active' : ''}`}
            style={{
                left: patchPoint.x,
                top: patchPoint.y,
                transform: 'translate(-50%, -50%)'
            }}
            onMouseDown={handleMouseDown}
            title={patchPoint.name}
        />
    );
}

/**
 * Control Component - Potentiometer or switch
 * @param {Object} props
 * @param {import('./modules.js').Control} props.control - Control data
 * @param {function} props.onChange - Called when control value changes
 */
function Control({ control, onChange }) {
    const handleChange = useCallback((e) => {
        const value = control.type === 'switch'
            ? (e.target.checked ? 1 : 0)
            : parseFloat(e.target.value);
        onChange(control.id, value);
    }, [control.id, control.type, onChange]);

    const handleInput = useCallback((e) => {
        const value = parseFloat(e.target.value);
        onChange(control.id, value);
    }, [control.id, onChange]);

    const handleMouseDown = useCallback((e) => {
        // Prevent module dragging when interacting with controls
        e.stopPropagation();
    }, []);

    if (control.type === 'switch') {
        return (
            <div
                className="switch"
                style={{ left: control.x, top: control.y }}
                title={control.name}
                onMouseDown={handleMouseDown}
            >
                <input
                    type="checkbox"
                    checked={control.value === 1}
                    onChange={handleChange}
                />
                <span className="slider"></span>
            </div>
        );
    }

    return (
        <div
            className="potentiometer"
            style={{ left: control.x, top: control.y }}
            title={control.name}
            onMouseDown={handleMouseDown}
        >
            <input
                type="range"
                min="0"
                max="1"
                step="0.01"
                value={control.value}
                onInput={handleInput}
                onChange={handleChange}
            />
        </div>
    );
}

/**
 * SequencerModule Component - Special sequencer module with step buttons
 * @param {Object} props
 * @param {Module} props.module - Module data
 * @param {function} props.onPatchPointMouseDown - Called when patch point clicked
 * @param {function} props.onControlChange - Called when control changes
 * @param {function} props.onModuleMove - Called when module is moved
 * @param {boolean} props.isConnecting - Whether currently connecting
 * @param {string|null} props.connectionStartId - ID of connection start point
 * @param {function} props.onStepChange - Called when step values change
 * @param {number[]} props.stepValues - Current step values
 * @param {number} props.currentStep - Current playing step
 */
function SequencerModule({ module, onPatchPointMouseDown, onControlChange, onModuleMove, isConnecting, connectionStartId, onStepChange, stepValues, currentStep }) {
    const [isDragging, setIsDragging] = useState(false);
    const [dragStart, setDragStart] = useState({ x: 0, y: 0 });
    const moduleRef = useRef(null);

    const handleMouseDown = useCallback((e) => {
        if (e.target.closest('.patch-point') || e.target.closest('.potentiometer, .switch') || e.target.closest('.step-btn')) {
            return; // Don't drag if clicking on patch points, controls, or step buttons
        }

        setIsDragging(true);
        const rect = moduleRef.current.getBoundingClientRect();
        setDragStart({
            x: e.clientX - rect.left,
            y: e.clientY - rect.top
        });
    }, []);

    const handleMouseMove = useCallback((e) => {
        if (!isDragging) return;

        const rackArea = moduleRef.current.parentElement;
        const rackRect = rackArea.getBoundingClientRect();

        const newX = Math.max(0, Math.min(
            e.clientX - rackRect.left - dragStart.x,
            rackRect.width - module.width
        ));
        const newY = Math.max(0, Math.min(
            e.clientY - rackRect.top - dragStart.y,
            rackRect.height - module.height
        ));

        onModuleMove(module.id, newX, newY);
    }, [isDragging, dragStart, module.id, module.width, module.height, onModuleMove]);

    const handleMouseUp = useCallback(() => {
        setIsDragging(false);
    }, []);

    // Add global mouse event listeners when dragging
    React.useEffect(() => {
        if (isDragging) {
            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);
            return () => {
                document.removeEventListener('mousemove', handleMouseMove);
                document.removeEventListener('mouseup', handleMouseUp);
            };
        }
    }, [isDragging, handleMouseMove, handleMouseUp]);

    const handleStepClick = useCallback((stepIndex) => {
        const newValue = stepValues[stepIndex] > 0 ? 0 : 0.5; // Toggle between off and middle C
        const newStepValues = [...stepValues];
        newStepValues[stepIndex] = newValue;
        onStepChange(module.id, newStepValues);
    }, [stepValues, onStepChange, module.id]);

    return (
        <div
            ref={moduleRef}
            className="module"
            style={{
                left: module.x,
                top: module.y,
                width: module.width,
                height: module.height,
                cursor: isDragging ? 'grabbing' : 'grab'
            }}
            onMouseDown={handleMouseDown}
        >
            <div className="module-header">{module.name}</div>

            {/* Step buttons */}
            <div style={{
                position: 'absolute',
                top: '50px',
                left: '10px',
                right: '10px',
                display: 'flex',
                justifyContent: 'space-between'
            }}>
                {[0, 1, 2, 3].map(stepIndex => (
                    <button
                        key={stepIndex}
                        className="step-btn"
                        style={{
                            width: '35px',
                            height: '35px',
                            backgroundColor: stepValues[stepIndex] > 0 ? '#4CAF50' : '#666',
                            border: currentStep === stepIndex ? '2px solid #ff0' : '1px solid #888',
                            borderRadius: '4px',
                            color: '#fff',
                            fontSize: '12px',
                            fontWeight: 'bold',
                            cursor: 'pointer',
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'center'
                        }}
                        onClick={() => handleStepClick(stepIndex)}
                    >
                        {stepIndex + 1}
                    </button>
                ))}
            </div>

            {module.patchPoints.map(patchPoint => (
                <React.Fragment key={patchPoint.id}>
                    <PatchPoint
                        patchPoint={patchPoint}
                        onMouseDown={onPatchPointMouseDown}
                        isConnecting={isConnecting}
                        connectionStartId={connectionStartId}
                    />
                    <div
                        style={{
                            position: 'absolute',
                            left: patchPoint.type === 'input' ? patchPoint.x + 8 : patchPoint.x - 35,
                            top: patchPoint.y - 8,
                            fontSize: '10px',
                            color: '#ccc',
                            pointerEvents: 'none',
                            whiteSpace: 'nowrap',
                            fontWeight: 'bold'
                        }}
                    >
                        {patchPoint.name}
                    </div>
                </React.Fragment>
            ))}

            {module.controls.map(control => (
                <Control
                    key={control.id}
                    control={control}
                    onChange={onControlChange}
                />
            ))}
        </div>
    );
}

/**
 * OscilloscopeModule Component - Special oscilloscope module for signal visualization
 * @param {Object} props
 * @param {Module} props.module - Module data
 * @param {function} props.onPatchPointMouseDown - Called when patch point clicked
 * @param {function} props.onControlChange - Called when control changes
 * @param {function} props.onModuleMove - Called when module is moved
 * @param {boolean} props.isConnecting - Whether currently connecting
 * @param {string|null} props.connectionStartId - ID of connection start point
 * @param {AudioEngine} props.audioEngine - Audio engine instance
 */
function OscilloscopeModule({ module, onPatchPointMouseDown, onControlChange, onModuleMove, isConnecting, connectionStartId, audioEngine }) {
    const [isDragging, setIsDragging] = useState(false);
    const [dragStart, setDragStart] = useState({ x: 0, y: 0 });
    const moduleRef = useRef(null);
    const canvasRef = useRef(null);
    const analyserRef = useRef(null);
    const animationRef = useRef(null);

    const handleMouseDown = useCallback((e) => {
        if (e.target.closest('.patch-point') || e.target.closest('.potentiometer, .switch')) {
            return; // Don't drag if clicking on patch points or controls
        }

        setIsDragging(true);
        const rect = moduleRef.current.getBoundingClientRect();
        setDragStart({
            x: e.clientX - rect.left,
            y: e.clientY - rect.top
        });
    }, []);

    const handleMouseMove = useCallback((e) => {
        if (!isDragging) return;

        const rackArea = moduleRef.current.parentElement;
        const rackRect = rackArea.getBoundingClientRect();

        const newX = Math.max(0, Math.min(
            e.clientX - rackRect.left - dragStart.x,
            rackRect.width - module.width
        ));
        const newY = Math.max(0, Math.min(
            e.clientY - rackRect.top - dragStart.y,
            rackRect.height - module.height
        ));

        onModuleMove(module.id, newX, newY);
    }, [isDragging, dragStart, module.id, module.width, module.height, onModuleMove]);

    const handleMouseUp = useCallback(() => {
        setIsDragging(false);
    }, []);

    // Add global mouse event listeners when dragging
    React.useEffect(() => {
        if (isDragging) {
            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);
            return () => {
                document.removeEventListener('mousemove', handleMouseMove);
                document.removeEventListener('mouseup', handleMouseUp);
            };
        }
    }, [isDragging, handleMouseMove, handleMouseUp]);

    // Oscilloscope visualization
    React.useEffect(() => {
        if (!audioEngine || !canvasRef.current) return;

        const canvas = canvasRef.current;
        const ctx = canvas.getContext('2d');

        // Get the analyser created by AudioEngine
        const analyser = audioEngine.audioNodes.get(module.id);
        if (!analyser) return;

        analyserRef.current = analyser;

        const bufferLength = analyser.frequencyBinCount;
        const dataArray = new Uint8Array(bufferLength);

        const draw = () => {
            analyser.getByteTimeDomainData(dataArray);

            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.lineWidth = 2;
            ctx.strokeStyle = '#0f0';
            ctx.beginPath();

            const sliceWidth = canvas.width / bufferLength;
            let x = 0;

            for (let i = 0; i < bufferLength; i++) {
                const v = dataArray[i] / 128.0;
                const y = v * canvas.height / 2;

                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }

                x += sliceWidth;
            }

            ctx.stroke();
            animationRef.current = requestAnimationFrame(draw);
        };

        draw();

        return () => {
            if (animationRef.current) {
                cancelAnimationFrame(animationRef.current);
            }
        };
    }, [audioEngine, module.id]);

    return (
        <div
            ref={moduleRef}
            className="module"
            style={{
                left: module.x,
                top: module.y,
                width: module.width,
                height: module.height,
                cursor: isDragging ? 'grabbing' : 'grab'
            }}
            onMouseDown={handleMouseDown}
        >
            <div className="module-header">{module.name}</div>

            {/* Oscilloscope display */}
            <canvas
                ref={canvasRef}
                width="160"
                height="80"
                style={{
                    position: 'absolute',
                    top: '40px',
                    left: '20px',
                    backgroundColor: '#000',
                    border: '1px solid #444'
                }}
            />

            {module.patchPoints.map(patchPoint => (
                <React.Fragment key={patchPoint.id}>
                    <PatchPoint
                        patchPoint={patchPoint}
                        onMouseDown={onPatchPointMouseDown}
                        isConnecting={isConnecting}
                        connectionStartId={connectionStartId}
                    />
                    <div
                        style={{
                            position: 'absolute',
                            left: patchPoint.type === 'input' ? patchPoint.x + 8 : patchPoint.x - 35,
                            top: patchPoint.y - 8,
                            fontSize: '10px',
                            color: '#ccc',
                            pointerEvents: 'none',
                            whiteSpace: 'nowrap',
                            fontWeight: 'bold'
                        }}
                    >
                        {patchPoint.name}
                    </div>
                </React.Fragment>
            ))}

            {module.controls.map(control => (
                <Control
                    key={control.id}
                    control={control}
                    onChange={onControlChange}
                />
            ))}
        </div>
    );
}

/**
 * LevelMeterModule Component - Simple level meter for signal monitoring
 * @param {Object} props
 * @param {Module} props.module - Module data
 * @param {function} props.onPatchPointMouseDown - Called when patch point clicked
 * @param {function} props.onControlChange - Called when control changes
 * @param {function} props.onModuleMove - Called when module is moved
 * @param {boolean} props.isConnecting - Whether currently connecting
 * @param {string|null} props.connectionStartId - ID of connection start point
 * @param {AudioEngine} props.audioEngine - Audio engine instance
 */
function LevelMeterModule({ module, onPatchPointMouseDown, onControlChange, onModuleMove, isConnecting, connectionStartId, audioEngine }) {
    const [isDragging, setIsDragging] = useState(false);
    const [dragStart, setDragStart] = useState({ x: 0, y: 0 });
    const [level, setLevel] = useState(0);
    const moduleRef = useRef(null);
    const analyserRef = useRef(null);
    const animationRef = useRef(null);

    const handleMouseDown = useCallback((e) => {
        if (e.target.closest('.patch-point')) {
            return; // Don't drag if clicking on patch points
        }

        setIsDragging(true);
        const rect = moduleRef.current.getBoundingClientRect();
        setDragStart({
            x: e.clientX - rect.left,
            y: e.clientY - rect.top
        });
    }, []);

    const handleMouseMove = useCallback((e) => {
        if (!isDragging) return;

        const rackArea = moduleRef.current.parentElement;
        const rackRect = rackArea.getBoundingClientRect();

        const newX = Math.max(0, Math.min(
            e.clientX - rackRect.left - dragStart.x,
            rackRect.width - module.width
        ));
        const newY = Math.max(0, Math.min(
            e.clientY - rackRect.top - dragStart.y,
            rackRect.height - module.height
        ));

        onModuleMove(module.id, newX, newY);
    }, [isDragging, dragStart, module.id, module.width, module.height, onModuleMove]);

    const handleMouseUp = useCallback(() => {
        setIsDragging(false);
    }, []);

    // Add global mouse event listeners when dragging
    React.useEffect(() => {
        if (isDragging) {
            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);
            return () => {
                document.removeEventListener('mousemove', handleMouseMove);
                document.removeEventListener('mouseup', handleMouseUp);
            };
        }
    }, [isDragging, handleMouseMove, handleMouseUp]);

    // Level meter monitoring
    React.useEffect(() => {
        if (!audioEngine) return;

        // Get the analyser created by AudioEngine
        const analyser = audioEngine.audioNodes.get(module.id);
        if (!analyser) return;

        analyserRef.current = analyser;

        const bufferLength = analyser.frequencyBinCount;
        const dataArray = new Uint8Array(bufferLength);

        const updateLevel = () => {
            analyser.getByteTimeDomainData(dataArray);

            // Calculate RMS level
            let sum = 0;
            for (let i = 0; i < bufferLength; i++) {
                const sample = (dataArray[i] - 128) / 128; // Convert to -1 to 1 range
                sum += sample * sample;
            }
            const rms = Math.sqrt(sum / bufferLength);

            // Convert to dB and scale to 0-1 range
            const dbLevel = 20 * Math.log10(rms + 0.0001); // Add small offset to avoid -inf
            const normalizedLevel = Math.max(0, Math.min(1, (dbLevel + 60) / 60)); // -60dB to 0dB range

            setLevel(normalizedLevel);
            animationRef.current = requestAnimationFrame(updateLevel);
        };

        updateLevel();

        return () => {
            if (animationRef.current) {
                cancelAnimationFrame(animationRef.current);
            }
        };
    }, [audioEngine, module.id]);

    return (
        <div
            ref={moduleRef}
            className="module"
            style={{
                left: module.x,
                top: module.y,
                width: module.width,
                height: module.height,
                cursor: isDragging ? 'grabbing' : 'grab'
            }}
            onMouseDown={handleMouseDown}
        >
            <div className="module-header">{module.name}</div>

            {/* Level meter display */}
            <div
                style={{
                    position: 'absolute',
                    top: '40px',
                    left: '20px',
                    width: '80px',
                    height: '80px',
                    backgroundColor: '#000',
                    border: '1px solid #444',
                    display: 'flex',
                    flexDirection: 'column',
                    alignItems: 'center',
                    justifyContent: 'center'
                }}
            >
                {/* Level bar */}
                <div
                    style={{
                        width: '20px',
                        height: '60px',
                        backgroundColor: '#333',
                        border: '1px solid #666',
                        position: 'relative',
                        marginBottom: '5px'
                    }}
                >
                    <div
                        style={{
                            position: 'absolute',
                            bottom: '0',
                            left: '0',
                            right: '0',
                            height: `${level * 100}%`,
                            backgroundColor: level > 0.8 ? '#f00' : level > 0.6 ? '#ff0' : '#0f0',
                            transition: 'height 0.1s ease-out'
                        }}
                    />
                </div>

                {/* Level value */}
                <div
                    style={{
                        fontSize: '12px',
                        color: '#fff',
                        fontFamily: 'monospace',
                        textAlign: 'center'
                    }}
                >
                    {Math.round(level * 100)}%
                </div>
            </div>

            {module.patchPoints.map(patchPoint => (
                <React.Fragment key={patchPoint.id}>
                    <PatchPoint
                        patchPoint={patchPoint}
                        onMouseDown={onPatchPointMouseDown}
                        isConnecting={isConnecting}
                        connectionStartId={connectionStartId}
                    />
                    <div
                        style={{
                            position: 'absolute',
                            left: patchPoint.type === 'input' ? patchPoint.x + 8 : patchPoint.x - 35,
                            top: patchPoint.y - 8,
                            fontSize: '10px',
                            color: '#ccc',
                            pointerEvents: 'none',
                            whiteSpace: 'nowrap',
                            fontWeight: 'bold'
                        }}
                    >
                        {patchPoint.name}
                    </div>
                </React.Fragment>
            ))}
        </div>
    );
}

/**
 * Module Component - Individual synth module
 * @param {Object} props
 * @param {Module} props.module - Module data
 * @param {function} props.onPatchPointMouseDown - Called when patch point clicked
 * @param {function} props.onControlChange - Called when control changes
 * @param {function} props.onModuleMove - Called when module is moved
 * @param {boolean} props.isConnecting - Whether currently connecting
 * @param {string|null} props.connectionStartId - ID of connection start point
 */
function SynthModule({ module, onPatchPointMouseDown, onControlChange, onModuleMove, isConnecting, connectionStartId }) {
    const [isDragging, setIsDragging] = useState(false);
    const [dragStart, setDragStart] = useState({ x: 0, y: 0 });
    const moduleRef = useRef(null);

    const handleMouseDown = useCallback((e) => {
        if (e.target.closest('.patch-point') || e.target.closest('.potentiometer, .switch')) {
            return; // Don't drag if clicking on patch points or controls
        }

        setIsDragging(true);
        const rect = moduleRef.current.getBoundingClientRect();
        setDragStart({
            x: e.clientX - rect.left,
            y: e.clientY - rect.top
        });
    }, []);

    const handleMouseMove = useCallback((e) => {
        if (!isDragging) return;

        const rackArea = moduleRef.current.parentElement;
        const rackRect = rackArea.getBoundingClientRect();

        const newX = Math.max(0, Math.min(
            e.clientX - rackRect.left - dragStart.x,
            rackRect.width - module.width
        ));
        const newY = Math.max(0, Math.min(
            e.clientY - rackRect.top - dragStart.y,
            rackRect.height - module.height
        ));

        onModuleMove(module.id, newX, newY);
    }, [isDragging, dragStart, module.id, module.width, module.height, onModuleMove]);

    const handleMouseUp = useCallback(() => {
        setIsDragging(false);
    }, []);

    // Add global mouse event listeners when dragging
    React.useEffect(() => {
        if (isDragging) {
            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);
            return () => {
                document.removeEventListener('mousemove', handleMouseMove);
                document.removeEventListener('mouseup', handleMouseUp);
            };
        }
    }, [isDragging, handleMouseMove, handleMouseUp]);

    return (
        <div
            ref={moduleRef}
            className="module"
            style={{
                left: module.x,
                top: module.y,
                width: module.width,
                height: module.height,
                cursor: isDragging ? 'grabbing' : 'grab'
            }}
            onMouseDown={handleMouseDown}
        >
            <div className="module-header">{module.name}</div>

            {module.patchPoints.map(patchPoint => (
                <React.Fragment key={patchPoint.id}>
                    <PatchPoint
                        patchPoint={patchPoint}
                        onMouseDown={onPatchPointMouseDown}
                        isConnecting={isConnecting}
                        connectionStartId={connectionStartId}
                    />
                    <div
                        style={{
                            position: 'absolute',
                            left: patchPoint.type === 'input' ? patchPoint.x + 8 : patchPoint.x - 35,
                            top: patchPoint.y - 8,
                            fontSize: '10px',
                            color: '#ccc',
                            pointerEvents: 'none',
                            whiteSpace: 'nowrap',
                            fontWeight: 'bold'
                        }}
                    >
                        {patchPoint.name}
                    </div>
                </React.Fragment>
            ))}

            {module.controls.map(control => (
                <Control
                    key={control.id}
                    control={control}
                    onChange={onControlChange}
                />
            ))}
        </div>
    );
}

/**
 * ConnectionLine Component - Visual connection between modules
 * @param {Object} props
 * @param {Connection} props.connection - Connection data
 * @param {Module[]} props.modules - All modules
 * @param {function} props.onRemove - Called when connection is clicked for removal
 */
function ConnectionLine({ connection, modules, onRemove }) {
    const getPatchPointPosition = useCallback((moduleId, patchId) => {
        const module = modules.find(m => m.id === moduleId);
        if (!module) return null;

        const patchPoint = module.patchPoints.find(p => p.id === patchId);
        if (!patchPoint) return null;

        return {
            x: module.x + patchPoint.x,
            y: module.y + patchPoint.y
        };
    }, [modules]);

    const fromPos = getPatchPointPosition(connection.fromModuleId, connection.fromPatchId);
    const toPos = getPatchPointPosition(connection.toModuleId, connection.toPatchId);

    if (!fromPos || !toPos) return null;

    const dx = toPos.x - fromPos.x;
    const dy = toPos.y - fromPos.y;
    const distance = Math.sqrt(dx * dx + dy * dy);

    // Create curved path
    const midX = (fromPos.x + toPos.x) / 2;
    const midY = (fromPos.y + toPos.y) / 2;
    const controlOffset = Math.abs(dx) > Math.abs(dy) ? Math.abs(dx) * 0.3 : Math.abs(dy) * 0.3;

    const pathData = `M ${fromPos.x} ${fromPos.y} Q ${midX} ${fromPos.y} ${midX} ${midY} Q ${midX} ${toPos.y} ${toPos.x} ${toPos.y}`;

    return (
        <svg
            className="connection"
            style={{
                position: 'absolute',
                top: 0,
                left: 0,
                width: '100%',
                height: '100%',
                pointerEvents: 'none',
                zIndex: 1
            }}
        >
            <path
                d={pathData}
                stroke="#0f0"
                strokeWidth="2"
                fill="none"
                style={{ pointerEvents: 'stroke', cursor: 'pointer' }}
                onClick={(e) => {
                    e.stopPropagation();
                    onRemove(connection.id);
                }}
            />
        </svg>
    );
}

/**
 * Rack Component - Main synthesis area
 * @param {Object} props
 * @param {Module[]} props.modules - Array of modules
 * @param {Connection[]} props.connections - Array of connections
 * @param {function} props.onDrop - Called when item is dropped
 * @param {function} props.onPatchPointMouseDown - Called when patch point clicked
 * @param {function} props.onControlChange - Called when control changes
 * @param {function} props.onSequencerControlChange - Called when sequencer control changes
 * @param {function} props.onModuleMove - Called when module is moved
 * @param {function} props.onConnectionRemove - Called when connection is removed
 * @param {boolean} props.isConnecting - Whether currently connecting
 * @param {string|null} props.connectionStartId - ID of connection start point
 * @param {function} props.onLoadState - Called when loading a new state
 * @param {Object} props.sequencerStates - Sequencer state for each sequencer module
 * @param {function} props.onStepChange - Called when step values change
 * @param {AudioEngine} props.audioEngine - Audio engine instance
 */
function Rack({
    modules,
    connections,
    onDrop,
    onPatchPointMouseDown,
    onControlChange,
    onSequencerControlChange,
    onModuleMove,
    onConnectionRemove,
    isConnecting,
    connectionStartId,
    onLoadState,
    sequencerStates,
    onStepChange,
    audioEngine
}) {
    const rackRef = useRef(null);
    const fileInputRef = useRef(null);

    const handleDragOver = useCallback((e) => {
        e.preventDefault();
    }, []);

    const handleDrop = useCallback((e) => {
        e.preventDefault();
        const type = e.dataTransfer.getData('text/plain');
        if (type && rackRef.current) {
            const rect = rackRef.current.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            onDrop(type, x, y);
        }
    }, [onDrop]);

    /**
     * Save current state as JSON
     */
    const handleSave = useCallback(() => {
        const state = {
            modules: modules.map(module => ({
                type: module.type,
                name: module.name,
                x: module.x,
                y: module.y,
                width: module.width,
                height: module.height,
                patchPoints: module.patchPoints.map(point => ({
                    id: point.id,
                    name: point.name,
                    type: point.type,
                    x: point.x,
                    y: point.y
                })),
                controls: module.controls.map(control => ({
                    id: control.id,
                    name: control.name,
                    type: control.type,
                    value: control.value,
                    x: control.x,
                    y: control.y
                }))
            })),
            connections: connections.map(connection => ({
                id: connection.id,
                fromModuleId: connection.fromModuleId,
                fromPatchId: connection.fromPatchId,
                toModuleId: connection.toModuleId,
                toPatchId: connection.toPatchId
            }))
        };

        const dataStr = JSON.stringify(state, null, 2);
        const dataBlob = new Blob([dataStr], { type: 'application/json' });
        const url = URL.createObjectURL(dataBlob);

        const link = document.createElement('a');
        link.href = url;
        link.download = 'modular-synth-patch.json';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
    }, [modules, connections]);

    /**
     * Handle file selection for loading
     */
    const handleFileSelect = useCallback((e) => {
        const file = e.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const state = JSON.parse(event.target.result);
                    onLoadState(state);
                } catch (error) {
                    console.error('Error loading JSON file:', error);
                    alert('Error loading file. Please check the JSON format.');
                }
            };
            reader.readAsText(file);
        }
        // Reset file input
        e.target.value = '';
    }, [onLoadState]);

    /**
     * Load default preset (2 oscillators -> mixer -> filter -> vca -> output with envelopes)
     */
    const handleLoadDefault = useCallback(() => {
        const defaultState = {
            modules: [
                // Oscillator 1
                {
                    type: 'oscillator',
                    name: 'Osc 1',
                    x: 20,
                    y: 20,
                    width: 140,
                    height: 120,
                    patchPoints: [
                        { id: 'osc1-patch-0', name: 'Out', type: 'output', x: 135, y: 60 }
                    ],
                    controls: [
                        { id: 'osc1-control-0', name: 'Frequency', type: 'potentiometer', value: 0.25, x: 20, y: 40 },
                        { id: 'osc1-control-1', name: 'Waveform', type: 'potentiometer', value: 0.0, x: 80, y: 40 }
                    ]
                },
                // Oscillator 2
                {
                    type: 'oscillator',
                    name: 'Osc 2',
                    x: 20,
                    y: 160,
                    width: 140,
                    height: 120,
                    patchPoints: [
                        { id: 'osc2-patch-0', name: 'Out', type: 'output', x: 135, y: 60 }
                    ],
                    controls: [
                        { id: 'osc2-control-0', name: 'Frequency', type: 'potentiometer', value: 0.35, x: 20, y: 40 },
                        { id: 'osc2-control-1', name: 'Waveform', type: 'potentiometer', value: 0.33, x: 80, y: 40 }
                    ]
                },
                // Mixer
                {
                    type: 'mixer',
                    name: 'Mixer',
                    x: 200,
                    y: 20,
                    width: 200,
                    height: 180,
                    patchPoints: [
                        { id: 'mixer-patch-0', name: 'In 1', type: 'input', x: -5, y: 35 },
                        { id: 'mixer-patch-1', name: 'In 2', type: 'input', x: -5, y: 65 },
                        { id: 'mixer-patch-2', name: 'In 3', type: 'input', x: -5, y: 95 },
                        { id: 'mixer-patch-3', name: 'In 4', type: 'input', x: -5, y: 125 },
                        { id: 'mixer-patch-4', name: 'Out', type: 'output', x: 195, y: 80 }
                    ],
                    controls: [
                        { id: 'mixer-control-0', name: 'Level 1', type: 'potentiometer', value: 0.8, x: 30, y: 25 },
                        { id: 'mixer-control-1', name: 'Level 2', type: 'potentiometer', value: 0.8, x: 30, y: 55 },
                        { id: 'mixer-control-2', name: 'Level 3', type: 'potentiometer', value: 0.0, x: 30, y: 85 },
                        { id: 'mixer-control-3', name: 'Level 4', type: 'potentiometer', value: 0.0, x: 30, y: 115 },
                        { id: 'mixer-control-4', name: 'Master', type: 'potentiometer', value: 0.7, x: 130, y: 70 }
                    ]
                },
                // Filter Envelope
                {
                    type: 'envelope',
                    name: 'Filter Env',
                    x: 450,
                    y: 20,
                    width: 140,
                    height: 160,
                    patchPoints: [
                        { id: 'filter-env-patch-0', name: 'Gate', type: 'input', x: -5, y: 80 },
                        { id: 'filter-env-patch-1', name: 'Out', type: 'output', x: 135, y: 80 }
                    ],
                    controls: [
                        { id: 'filter-env-control-0', name: 'Attack', type: 'potentiometer', value: 0.1, x: 20, y: 40 },
                        { id: 'filter-env-control-1', name: 'Decay', type: 'potentiometer', value: 0.3, x: 80, y: 40 },
                        { id: 'filter-env-control-2', name: 'Sustain', type: 'potentiometer', value: 0.7, x: 20, y: 80 },
                        { id: 'filter-env-control-3', name: 'Release', type: 'potentiometer', value: 0.4, x: 80, y: 80 }
                    ]
                },
                // VCF Filter
                {
                    type: 'vcf',
                    name: 'VCF',
                    x: 620,
                    y: 20,
                    width: 140,
                    height: 140,
                    patchPoints: [
                        { id: 'vcf-patch-0', name: 'In', type: 'input', x: -5, y: 40 },
                        { id: 'vcf-patch-1', name: 'Cutoff Mod', type: 'input', x: -5, y: 80 },
                        { id: 'vcf-patch-2', name: 'Out', type: 'output', x: 135, y: 60 }
                    ],
                    controls: [
                        { id: 'vcf-control-0', name: 'Cutoff', type: 'potentiometer', value: 0.4, x: 20, y: 40 },
                        { id: 'vcf-control-1', name: 'Resonance', type: 'potentiometer', value: 0.3, x: 80, y: 40 }
                    ]
                },
                // Amp Envelope
                {
                    type: 'envelope',
                    name: 'Amp Env',
                    x: 450,
                    y: 200,
                    width: 140,
                    height: 160,
                    patchPoints: [
                        { id: 'amp-env-patch-0', name: 'Gate', type: 'input', x: -5, y: 80 },
                        { id: 'amp-env-patch-1', name: 'Out', type: 'output', x: 135, y: 80 }
                    ],
                    controls: [
                        { id: 'amp-env-control-0', name: 'Attack', type: 'potentiometer', value: 0.05, x: 20, y: 40 },
                        { id: 'amp-env-control-1', name: 'Decay', type: 'potentiometer', value: 0.2, x: 80, y: 40 },
                        { id: 'amp-env-control-2', name: 'Sustain', type: 'potentiometer', value: 0.8, x: 20, y: 80 },
                        { id: 'amp-env-control-3', name: 'Release', type: 'potentiometer', value: 0.6, x: 80, y: 80 }
                    ]
                },
                // VCA
                {
                    type: 'vca',
                    name: 'VCA',
                    x: 620,
                    y: 180,
                    width: 140,
                    height: 120,
                    patchPoints: [
                        { id: 'vca-patch-0', name: 'Audio In', type: 'input', x: -5, y: 40 },
                        { id: 'vca-patch-1', name: 'CV In', type: 'input', x: -5, y: 80 },
                        { id: 'vca-patch-2', name: 'Out', type: 'output', x: 135, y: 60 }
                    ],
                    controls: [
                        { id: 'vca-control-0', name: 'Level', type: 'potentiometer', value: 0.0, x: 50, y: 40 }
                    ]
                },
                // Output
                {
                    type: 'output',
                    name: 'Output',
                    x: 800,
                    y: 100,
                    width: 140,
                    height: 120,
                    patchPoints: [
                        { id: 'output-patch-0', name: 'Audio In', type: 'input', x: -5, y: 60 }
                    ],
                    controls: [
                        { id: 'output-control-0', name: 'Volume', type: 'potentiometer', value: 0.9, x: 50, y: 40 }
                    ]
                }
            ],
            connections: [
                // Osc 1 -> Mixer In 1
                {
                    id: 'connection-osc1-mixer1',
                    fromModuleId: 'osc1',
                    fromPatchId: 'osc1-patch-0',
                    toModuleId: 'mixer',
                    toPatchId: 'mixer-patch-0'
                },
                // Osc 2 -> Mixer In 2
                {
                    id: 'connection-osc2-mixer2',
                    fromModuleId: 'osc2',
                    fromPatchId: 'osc2-patch-0',
                    toModuleId: 'mixer',
                    toPatchId: 'mixer-patch-1'
                },
                // Mixer -> VCF
                {
                    id: 'connection-mixer-vcf',
                    fromModuleId: 'mixer',
                    fromPatchId: 'mixer-patch-4',
                    toModuleId: 'vcf',
                    toPatchId: 'vcf-patch-0'
                },
                // Filter Env -> VCF Cutoff Mod
                {
                    id: 'connection-filter-env-vcf',
                    fromModuleId: 'filter-env',
                    fromPatchId: 'filter-env-patch-1',
                    toModuleId: 'vcf',
                    toPatchId: 'vcf-patch-1'
                },
                // VCF -> VCA Audio In
                {
                    id: 'connection-vcf-vca',
                    fromModuleId: 'vcf',
                    fromPatchId: 'vcf-patch-2',
                    toModuleId: 'vca',
                    toPatchId: 'vca-patch-0'
                },
                // Amp Env -> VCA CV In
                {
                    id: 'connection-amp-env-vca',
                    fromModuleId: 'amp-env',
                    fromPatchId: 'amp-env-patch-1',
                    toModuleId: 'vca',
                    toPatchId: 'vca-patch-1'
                },
                // VCA -> Output
                {
                    id: 'connection-vca-output',
                    fromModuleId: 'vca',
                    fromPatchId: 'vca-patch-2',
                    toModuleId: 'output',
                    toPatchId: 'output-patch-0'
                }
            ]
        };

        onLoadState(defaultState);
    }, [onLoadState]);

    return (
        <div className="rack">
            <h2>
                Rack
                <div className="controls">
                    <button className="save-btn" onClick={handleSave}>Save</button>
                    <button className="load-btn" onClick={() => fileInputRef.current?.click()}>
                        Load
                        <input
                            ref={fileInputRef}
                            type="file"
                            accept=".json"
                            onChange={handleFileSelect}
                            className="load-input"
                        />
                    </button>
                    <button className="save-btn" onClick={handleLoadDefault}>Default</button>
                </div>
            </h2>
            <div
                ref={rackRef}
                className="rack-area"
                onDragOver={handleDragOver}
                onDrop={handleDrop}
            >
                {modules.map(module => {
                    if (module.type === 'sequencer') {
                        const sequencerState = sequencerStates[module.id] || {
                            stepValues: [0.5, 0, 0.3, 0],
                            currentStep: 0,
                            isPlaying: false,
                            tempo: 120
                        };
                        return (
                            <SequencerModule
                                key={module.id}
                                module={module}
                                onPatchPointMouseDown={onPatchPointMouseDown}
                                onControlChange={onSequencerControlChange}
                                onModuleMove={onModuleMove}
                                isConnecting={isConnecting}
                                connectionStartId={connectionStartId}
                                onStepChange={onStepChange}
                                stepValues={sequencerState.stepValues}
                                currentStep={sequencerState.currentStep}
                            />
                        );
                    } else if (module.type === 'oscilloscope') {
                        return (
                            <OscilloscopeModule
                                key={module.id}
                                module={module}
                                onPatchPointMouseDown={onPatchPointMouseDown}
                                onControlChange={onControlChange}
                                onModuleMove={onModuleMove}
                                isConnecting={isConnecting}
                                connectionStartId={connectionStartId}
                                audioEngine={audioEngine}
                            />
                        );
                    } else if (module.type === 'level-meter') {
                        return (
                            <LevelMeterModule
                                key={module.id}
                                module={module}
                                onPatchPointMouseDown={onPatchPointMouseDown}
                                onControlChange={onControlChange}
                                onModuleMove={onModuleMove}
                                isConnecting={isConnecting}
                                connectionStartId={connectionStartId}
                                audioEngine={audioEngine}
                            />
                        );
                    } else {
                        return (
                            <SynthModule
                                key={module.id}
                                module={module}
                                onPatchPointMouseDown={onPatchPointMouseDown}
                                onControlChange={onControlChange}
                                onModuleMove={onModuleMove}
                                isConnecting={isConnecting}
                                connectionStartId={connectionStartId}
                            />
                        );
                    }
                })}

                {connections.map(connection => (
                    <ConnectionLine
                        key={connection.id}
                        connection={connection}
                        modules={modules}
                        onRemove={onConnectionRemove}
                    />
                ))}
            </div>
        </div>
    );
}

/**
 * Main App Component
 */
function App() {
    /** @type {[Module[], function]} */
    const [modules, setModules] = useState([]);
    /** @type {[Connection[], function]} */
    const [connections, setConnections] = useState([]);
    /** @type {[boolean, function]} */
    const [isConnecting, setIsConnecting] = useState(false);
    /** @type {[string|null, function]} */
    const [connectionStart, setConnectionStart] = useState(null);
    /** @type {[AudioEngine, function]} */
    const [audioEngine, setAudioEngine] = useState(null);
    /** @type {[Object, function]} */
    const [sequencerStates, setSequencerStates] = useState({});

    // Initialize audio engine
    React.useEffect(() => {
        const engine = new AudioEngine();
        engine.init().then(() => {
            setAudioEngine(engine);
        });
    }, []);

    // Load default preset on app start
    React.useEffect(() => {
        if (audioEngine && modules.length === 0) {
            const defaultState = {
                modules: [
                    // Oscillator 1
                    {
                        type: 'oscillator',
                        name: 'Osc 1',
                        x: 20,
                        y: 20,
                        width: 140,
                        height: 120,
                        patchPoints: [
                            { id: 'osc1-patch-0', name: 'Out', type: 'output', x: 135, y: 60 }
                        ],
                        controls: [
                            { id: 'osc1-control-0', name: 'Frequency', type: 'potentiometer', value: 0.25, x: 20, y: 40 },
                            { id: 'osc1-control-1', name: 'Waveform', type: 'potentiometer', value: 0.0, x: 80, y: 40 }
                        ]
                    },
                    // Oscillator 2
                    {
                        type: 'oscillator',
                        name: 'Osc 2',
                        x: 20,
                        y: 160,
                        width: 140,
                        height: 120,
                        patchPoints: [
                            { id: 'osc2-patch-0', name: 'Out', type: 'output', x: 135, y: 60 }
                        ],
                        controls: [
                            { id: 'osc2-control-0', name: 'Frequency', type: 'potentiometer', value: 0.35, x: 20, y: 40 },
                            { id: 'osc2-control-1', name: 'Waveform', type: 'potentiometer', value: 0.33, x: 80, y: 40 }
                        ]
                    },
                    // Mixer
                    {
                        type: 'mixer',
                        name: 'Mixer',
                        x: 200,
                        y: 20,
                        width: 200,
                        height: 180,
                        patchPoints: [
                            { id: 'mixer-patch-0', name: 'In 1', type: 'input', x: -5, y: 35 },
                            { id: 'mixer-patch-1', name: 'In 2', type: 'input', x: -5, y: 65 },
                            { id: 'mixer-patch-2', name: 'In 3', type: 'input', x: -5, y: 95 },
                            { id: 'mixer-patch-3', name: 'In 4', type: 'input', x: -5, y: 125 },
                            { id: 'mixer-patch-4', name: 'Out', type: 'output', x: 195, y: 80 }
                        ],
                        controls: [
                            { id: 'mixer-control-0', name: 'Level 1', type: 'potentiometer', value: 0.8, x: 30, y: 25 },
                            { id: 'mixer-control-1', name: 'Level 2', type: 'potentiometer', value: 0.8, x: 30, y: 55 },
                            { id: 'mixer-control-2', name: 'Level 3', type: 'potentiometer', value: 0.0, x: 30, y: 85 },
                            { id: 'mixer-control-3', name: 'Level 4', type: 'potentiometer', value: 0.0, x: 30, y: 115 },
                            { id: 'mixer-control-4', name: 'Master', type: 'potentiometer', value: 0.7, x: 130, y: 70 }
                        ]
                    },
                    // Filter Envelope
                    {
                        type: 'envelope',
                        name: 'Filter Env',
                        x: 450,
                        y: 20,
                        width: 140,
                        height: 160,
                        patchPoints: [
                            { id: 'filter-env-patch-0', name: 'Gate', type: 'input', x: -5, y: 80 },
                            { id: 'filter-env-patch-1', name: 'Out', type: 'output', x: 135, y: 80 }
                        ],
                        controls: [
                            { id: 'filter-env-control-0', name: 'Attack', type: 'potentiometer', value: 0.1, x: 20, y: 40 },
                            { id: 'filter-env-control-1', name: 'Decay', type: 'potentiometer', value: 0.3, x: 80, y: 40 },
                            { id: 'filter-env-control-2', name: 'Sustain', type: 'potentiometer', value: 0.7, x: 20, y: 80 },
                            { id: 'filter-env-control-3', name: 'Release', type: 'potentiometer', value: 0.4, x: 80, y: 80 }
                        ]
                    },
                    // VCF Filter
                    {
                        type: 'vcf',
                        name: 'VCF',
                        x: 620,
                        y: 20,
                        width: 140,
                        height: 140,
                        patchPoints: [
                            { id: 'vcf-patch-0', name: 'In', type: 'input', x: -5, y: 40 },
                            { id: 'vcf-patch-1', name: 'Cutoff Mod', type: 'input', x: -5, y: 80 },
                            { id: 'vcf-patch-2', name: 'Out', type: 'output', x: 135, y: 60 }
                        ],
                        controls: [
                            { id: 'vcf-control-0', name: 'Cutoff', type: 'potentiometer', value: 0.4, x: 20, y: 40 },
                            { id: 'vcf-control-1', name: 'Resonance', type: 'potentiometer', value: 0.3, x: 80, y: 40 }
                        ]
                    },
                    // Amp Envelope
                    {
                        type: 'envelope',
                        name: 'Amp Env',
                        x: 450,
                        y: 200,
                        width: 140,
                        height: 160,
                        patchPoints: [
                            { id: 'amp-env-patch-0', name: 'Gate', type: 'input', x: -5, y: 80 },
                            { id: 'amp-env-patch-1', name: 'Out', type: 'output', x: 135, y: 80 }
                        ],
                        controls: [
                            { id: 'amp-env-control-0', name: 'Attack', type: 'potentiometer', value: 0.05, x: 20, y: 40 },
                            { id: 'amp-env-control-1', name: 'Decay', type: 'potentiometer', value: 0.2, x: 80, y: 40 },
                            { id: 'amp-env-control-2', name: 'Sustain', type: 'potentiometer', value: 0.8, x: 20, y: 80 },
                            { id: 'amp-env-control-3', name: 'Release', type: 'potentiometer', value: 0.6, x: 80, y: 80 }
                        ]
                    },
                    // VCA
                    {
                        type: 'vca',
                        name: 'VCA',
                        x: 620,
                        y: 180,
                        width: 140,
                        height: 120,
                        patchPoints: [
                            { id: 'vca-patch-0', name: 'Audio In', type: 'input', x: -5, y: 40 },
                            { id: 'vca-patch-1', name: 'CV In', type: 'input', x: -5, y: 80 },
                            { id: 'vca-patch-2', name: 'Out', type: 'output', x: 135, y: 60 }
                        ],
                        controls: [
                            { id: 'vca-control-0', name: 'Level', type: 'potentiometer', value: 0.0, x: 50, y: 40 }
                        ]
                    },
                    // Output
                    {
                        type: 'output',
                        name: 'Output',
                        x: 800,
                        y: 100,
                        width: 140,
                        height: 120,
                        patchPoints: [
                            { id: 'output-patch-0', name: 'Audio In', type: 'input', x: -5, y: 60 }
                        ],
                        controls: [
                            { id: 'output-control-0', name: 'Volume', type: 'potentiometer', value: 0.9, x: 50, y: 40 }
                        ]
                    }
                ],
                connections: [
                    // Osc 1 -> Mixer In 1
                    {
                        id: 'connection-osc1-mixer1',
                        fromModuleId: 'osc1',
                        fromPatchId: 'osc1-patch-0',
                        toModuleId: 'mixer',
                        toPatchId: 'mixer-patch-0'
                    },
                    // Osc 2 -> Mixer In 2
                    {
                        id: 'connection-osc2-mixer2',
                        fromModuleId: 'osc2',
                        fromPatchId: 'osc2-patch-0',
                        toModuleId: 'mixer',
                        toPatchId: 'mixer-patch-1'
                    },
                    // Mixer -> VCF
                    {
                        id: 'connection-mixer-vcf',
                        fromModuleId: 'mixer',
                        fromPatchId: 'mixer-patch-4',
                        toModuleId: 'vcf',
                        toPatchId: 'vcf-patch-0'
                    },
                    // Filter Env -> VCF Cutoff Mod
                    {
                        id: 'connection-filter-env-vcf',
                        fromModuleId: 'filter-env',
                        fromPatchId: 'filter-env-patch-1',
                        toModuleId: 'vcf',
                        toPatchId: 'vcf-patch-1'
                    },
                    // VCF -> VCA Audio In
                    {
                        id: 'connection-vcf-vca',
                        fromModuleId: 'vcf',
                        fromPatchId: 'vcf-patch-2',
                        toModuleId: 'vca',
                        toPatchId: 'vca-patch-0'
                    },
                    // Amp Env -> VCA CV In
                    {
                        id: 'connection-amp-env-vca',
                        fromModuleId: 'amp-env',
                        fromPatchId: 'amp-env-patch-1',
                        toModuleId: 'vca',
                        toPatchId: 'vca-patch-1'
                    },
                    // VCA -> Output
                    {
                        id: 'connection-vca-output',
                        fromModuleId: 'vca',
                        fromPatchId: 'vca-patch-2',
                        toModuleId: 'output',
                        toPatchId: 'output-patch-0'
                    }
                ]
            };

            // Create new modules with fresh IDs
            const newModules = defaultState.modules.map(moduleData => {
                const template = MODULE_TEMPLATES[moduleData.type];
                if (!template) {
                    console.warn(`Unknown module type: ${moduleData.type}`);
                    return null;
                }

                const moduleId = `${moduleData.type}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;

                return {
                    id: moduleId,
                    ...template,
                    x: moduleData.x,
                    y: moduleData.y,
                    patchPoints: template.patchPoints.map((point, index) => ({
                        ...point,
                        id: `${moduleId}-patch-${index}`
                    })),
                    controls: moduleData.controls.map((controlData, index) => ({
                        ...template.controls[index],
                        id: `${moduleId}-control-${index}`,
                        value: controlData.value
                    }))
                };
            }).filter(Boolean);

            // Create connections with updated module IDs
            const newConnections = defaultState.connections.map(connectionData => {
                // Find modules by matching patch point names
                const fromModuleIndex = defaultState.modules.findIndex(m =>
                    m.patchPoints.some(p => p.id === connectionData.fromPatchId)
                );
                const toModuleIndex = defaultState.modules.findIndex(m =>
                    m.patchPoints.some(p => p.id === connectionData.toPatchId)
                );

                if (fromModuleIndex === -1 || toModuleIndex === -1) {
                    console.warn('Could not find modules for connection:', connectionData);
                    return null;
                }

                const fromModule = newModules[fromModuleIndex];
                const toModule = newModules[toModuleIndex];

                if (!fromModule || !toModule) return null;

                // Find patch points by name
                const fromPatchName = defaultState.modules[fromModuleIndex].patchPoints.find(p => p.id === connectionData.fromPatchId)?.name;
                const toPatchName = defaultState.modules[toModuleIndex].patchPoints.find(p => p.id === connectionData.toPatchId)?.name;

                if (!fromPatchName || !toPatchName) return null;

                const fromPatch = fromModule.patchPoints.find(p => p.name === fromPatchName);
                const toPatch = toModule.patchPoints.find(p => p.name === toPatchName);

                if (!fromPatch || !toPatch) return null;

                return createConnection(fromModule.id, fromPatch.id, toModule.id, toPatch.id);
            }).filter(Boolean);

            // Update state
            setModules(newModules);
            setConnections(newConnections);
        }
    }, [audioEngine, modules.length]);

    // Resume audio context on user interaction
    React.useEffect(() => {
        const resumeAudio = async () => {
            if (audioEngine && audioEngine.audioContext && audioEngine.audioContext.state === 'suspended') {
                try {
                    await audioEngine.audioContext.resume();
                    console.log('Audio context resumed');
                } catch (error) {
                    console.error('Failed to resume audio context:', error);
                }
            }
        };

        const handleInteraction = () => {
            resumeAudio();
            // Remove listeners after first interaction
            document.removeEventListener('click', handleInteraction);
            document.removeEventListener('keydown', handleInteraction);
        };

        document.addEventListener('click', handleInteraction);
        document.addEventListener('keydown', handleInteraction);

        return () => {
            document.removeEventListener('click', handleInteraction);
            document.removeEventListener('keydown', handleInteraction);
        };
    }, [audioEngine]);

    // Create audio nodes when modules are added
    React.useEffect(() => {
        if (!audioEngine) return;

        modules.forEach(module => {
            if (!audioEngine.audioNodes.has(module.id) && !audioEngine.gainNodes.has(module.id)) {
                audioEngine.createAudioNode(module);
            }
        });
    }, [modules, audioEngine]);

    // Update audio parameters when modules change
    React.useEffect(() => {
        if (!audioEngine) return;

        modules.forEach(module => {
            audioEngine.updateModule(module);
        });
    }, [modules, audioEngine]);

    // Update audio connections when connections change
    React.useEffect(() => {
        if (!audioEngine) return;

        audioEngine.updateConnections(modules, connections);
    }, [connections, modules, audioEngine]);

    /**
     * Handle module creation from drag and drop
     * @param {string} type - Module type
     * @param {number} x - X position
     * @param {number} y - Y position
     */
    const handleModuleDrop = useCallback((type, x, y) => {
        try {
            const newModule = createModule(type, x, y);
            setModules(prev => [...prev, newModule]);
        } catch (error) {
            console.error('Error creating module:', error);
        }
    }, []);

    /**
     * Handle patch point mouse down for connections
     * @param {string} patchPointId - ID of clicked patch point
     */
    const handlePatchPointMouseDown = useCallback((patchPointId) => {
        if (!isConnecting) {
            // Start connection
            setIsConnecting(true);
            setConnectionStart(patchPointId);
        } else {
            // Complete connection
            if (connectionStart && connectionStart !== patchPointId) {
                // Find modules and patch points
                let fromModule = null;
                let fromPatch = null;
                let toModule = null;
                let toPatch = null;

                for (const module of modules) {
                    const fromPatchPoint = module.patchPoints.find(p => p.id === connectionStart);
                    const toPatchPoint = module.patchPoints.find(p => p.id === patchPointId);

                    if (fromPatchPoint) {
                        fromModule = module;
                        fromPatch = fromPatchPoint;
                    }
                    if (toPatchPoint) {
                        toModule = module;
                        toPatch = toPatchPoint;
                    }
                }

                if (fromModule && fromPatch && toModule && toPatch) {
                    // Validate connection (output to input)
                    if (fromPatch.type === 'output' && toPatch.type === 'input') {
                        const newConnection = createConnection(
                            fromModule.id,
                            fromPatch.id,
                            toModule.id,
                            toPatch.id
                        );
                        setConnections(prev => [...prev, newConnection]);
                    }
                }
            }

            setIsConnecting(false);
            setConnectionStart(null);
        }
    }, [isConnecting, connectionStart, modules]);

    /**
     * Handle control value changes
     * @param {string} controlId - ID of control
     * @param {number} value - New value
     */
    const handleControlChange = useCallback((controlId, value) => {
        setModules(prev => prev.map(module => ({
            ...module,
            controls: module.controls.map(control =>
                control.id === controlId ? { ...control, value } : control
            )
        })));
    }, []);

    /**
     * Handle module movement
     * @param {string} moduleId - ID of module
     * @param {number} x - New X position
     * @param {number} y - New Y position
     */
    const handleModuleMove = useCallback((moduleId, x, y) => {
        setModules(prev => prev.map(module =>
            module.id === moduleId ? { ...module, x, y } : module
        ));
    }, []);

    /**
     * Handle connection removal
     * @param {string} connectionId - ID of connection to remove
     */
    const handleConnectionRemove = useCallback((connectionId) => {
        setConnections(prev => {
            const newConnections = prev.filter(conn => conn.id !== connectionId);
            // Audio connections will be updated via useEffect when connections state changes
            return newConnections;
        });
    }, []);

    /**
     * Handle loading a new state from JSON
     * @param {Object} state - State object with modules and connections
     */
    const handleLoadState = useCallback((state) => {
        if (!state.modules || !state.connections) {
            console.error('Invalid state format');
            return;
        }

        // Clear current audio nodes
        if (audioEngine) {
            modules.forEach(module => {
                audioEngine.removeModule(module.id);
            });
        }

        // Create new modules with fresh IDs
        const newModules = state.modules.map(moduleData => {
            const template = MODULE_TEMPLATES[moduleData.type];
            if (!template) {
                console.warn(`Unknown module type: ${moduleData.type}`);
                return null;
            }

            const moduleId = `${moduleData.type}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;

            return {
                id: moduleId,
                ...template,
                x: moduleData.x,
                y: moduleData.y,
                patchPoints: template.patchPoints.map((point, index) => ({
                    ...point,
                    id: `${moduleId}-patch-${index}`
                })),
                controls: moduleData.controls.map((controlData, index) => ({
                    ...template.controls[index],
                    id: `${moduleId}-control-${index}`,
                    value: controlData.value
                }))
            };
        }).filter(Boolean);

        // Create connections with updated module IDs
        const newConnections = state.connections.map(connectionData => {
            // Find modules by matching patch point names
            const fromModuleIndex = state.modules.findIndex(m =>
                m.patchPoints.some(p => p.id === connectionData.fromPatchId)
            );
            const toModuleIndex = state.modules.findIndex(m =>
                m.patchPoints.some(p => p.id === connectionData.toPatchId)
            );

            if (fromModuleIndex === -1 || toModuleIndex === -1) {
                console.warn('Could not find modules for connection:', connectionData);
                return null;
            }

            const fromModule = newModules[fromModuleIndex];
            const toModule = newModules[toModuleIndex];

            if (!fromModule || !toModule) return null;

            // Find patch points by name
            const fromPatchName = state.modules[fromModuleIndex].patchPoints.find(p => p.id === connectionData.fromPatchId)?.name;
            const toPatchName = state.modules[toModuleIndex].patchPoints.find(p => p.id === connectionData.toPatchId)?.name;

            if (!fromPatchName || !toPatchName) return null;

            const fromPatch = fromModule.patchPoints.find(p => p.name === fromPatchName);
            const toPatch = toModule.patchPoints.find(p => p.name === toPatchName);

            if (!fromPatch || !toPatch) return null;

            return createConnection(fromModule.id, fromPatch.id, toModule.id, toPatch.id);
        }).filter(Boolean);

        // Update state
        setModules(newModules);
        setConnections(newConnections);
        setIsConnecting(false);
        setConnectionStart(null);
    }, [audioEngine, modules]);

    /**
     * Handle drag start from module panel
     * @param {DragEvent} e - Drag event
     * @param {string} type - Module type
     */
    const handleDragStart = useCallback((e, type) => {
        e.dataTransfer.setData('text/plain', type);
    }, []);

    /**
     * Handle step value changes for sequencers
     * @param {string} sequencerId - ID of the sequencer module
     * @param {number[]} stepValues - New step values
     */
    const handleStepChange = useCallback((sequencerId, stepValues) => {
        setSequencerStates(prev => ({
            ...prev,
            [sequencerId]: {
                ...prev[sequencerId],
                stepValues: stepValues
            }
        }));
    }, []);

    /**
     * Handle control changes for sequencers (tempo and play/stop)
     */
    const handleSequencerControlChange = useCallback((controlId, value) => {
        // Find which sequencer this control belongs to
        const sequencerModule = modules.find(module =>
            module.type === 'sequencer' &&
            module.controls.some(control => control.id === controlId)
        );

        if (!sequencerModule) return;

        const control = sequencerModule.controls.find(c => c.id === controlId);
        if (!control) return;

        if (control.name === 'Tempo') {
            // Map 0-1 to 60-240 BPM
            const tempo = 60 + (value * 180);
            setSequencerStates(prev => ({
                ...prev,
                [sequencerModule.id]: {
                    ...prev[sequencerModule.id],
                    tempo: tempo
                }
            }));
        } else if (control.name === 'Play/Stop') {
            const isPlaying = value === 1;
            setSequencerStates(prev => ({
                ...prev,
                [sequencerModule.id]: {
                    ...prev[sequencerModule.id],
                    isPlaying: isPlaying,
                    currentStep: isPlaying ? prev[sequencerModule.id]?.currentStep || 0 : 0
                }
            }));
        }

        // Also update the module control value
        handleControlChange(controlId, value);
    }, [modules, handleControlChange]);

    // Sequencer timing logic
    React.useEffect(() => {
        const intervals = new Map();

        Object.entries(sequencerStates).forEach(([sequencerId, state]) => {
            if (state.isPlaying && state.tempo) {
                const intervalMs = (60 / state.tempo) * 1000; // Convert BPM to milliseconds per step

                if (!intervals.has(sequencerId)) {
                    const interval = setInterval(() => {
                        setSequencerStates(prev => {
                            const currentState = prev[sequencerId];
                            if (!currentState || !currentState.isPlaying) return prev;

                            const nextStep = (currentState.currentStep + 1) % 4;
                            const stepValue = currentState.stepValues[nextStep];

                            // Update CV and gate outputs
                            if (audioEngine) {
                                // CV output (pitch)
                                const cvGain = audioEngine.gainNodes.get(`${sequencerId}-cv`);
                                if (cvGain) {
                                    cvGain.gain.value = stepValue; // 0-1 range for pitch
                                }

                                // Gate output (trigger)
                                const gateGain = audioEngine.gainNodes.get(`${sequencerId}-gate`);
                                if (gateGain) {
                                    gateGain.gain.value = stepValue > 0 ? 1 : 0; // Gate on/off
                                }
                            }

                            return {
                                ...prev,
                                [sequencerId]: {
                                    ...currentState,
                                    currentStep: nextStep
                                }
                            };
                        });
                    }, intervalMs);

                    intervals.set(sequencerId, interval);
                }
            } else {
                // Stop playing
                const interval = intervals.get(sequencerId);
                if (interval) {
                    clearInterval(interval);
                    intervals.delete(sequencerId);
                }
            }
        });

        // Cleanup intervals on unmount
        return () => {
            intervals.forEach(interval => clearInterval(interval));
        };
    }, [sequencerStates, audioEngine]);

    // Initialize sequencer states when modules are created
    React.useEffect(() => {
        const sequencerModules = modules.filter(module => module.type === 'sequencer');

        setSequencerStates(prev => {
            const newStates = { ...prev };

            sequencerModules.forEach(module => {
                if (!newStates[module.id]) {
                    newStates[module.id] = {
                        stepValues: [0.5, 0, 0.3, 0], // Default step values
                        currentStep: 0,
                        isPlaying: false,
                        tempo: 120
                    };
                }

                // Create CV and gate output nodes
                if (audioEngine && !audioEngine.gainNodes.has(`${module.id}-cv`)) {
                    const cvGain = audioEngine.audioContext.createGain();
                    cvGain.gain.value = 0;
                    audioEngine.gainNodes.set(`${module.id}-cv`, cvGain);

                    const gateGain = audioEngine.audioContext.createGain();
                    gateGain.gain.value = 0;
                    audioEngine.gainNodes.set(`${module.id}-gate`, gateGain);
                }
            });

            return newStates;
        });
    }, [modules, audioEngine]);

    return (
        <div className="container">
            <ModulePanel onDragStart={handleDragStart} />
            <Rack
                modules={modules}
                connections={connections}
                onDrop={handleModuleDrop}
                onPatchPointMouseDown={handlePatchPointMouseDown}
                onControlChange={handleControlChange}
                onSequencerControlChange={handleSequencerControlChange}
                onModuleMove={handleModuleMove}
                onConnectionRemove={handleConnectionRemove}
                isConnecting={isConnecting}
                connectionStartId={connectionStart}
                onLoadState={handleLoadState}
                sequencerStates={sequencerStates}
                onStepChange={handleStepChange}
                audioEngine={audioEngine}
            />
        </div>
    );
}

// Render the React app
const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<App />);
    </script>
</body>
</html>
