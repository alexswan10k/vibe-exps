<!DOCTYPE html>
<html lang="en">
<head>
    <title>Human Authorship Verifier - Verification Tool</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="hav-core.js"></script>
    <script>
        // Add missing verification functions to global scope
        async function verifySignature(signedDataStr, signature, publicKey) {
            try {
                // Import public key for verification
                const publicKeyObj = await crypto.subtle.importKey(
                    'jwk',
                    publicKey,
                    {
                        name: 'RSA-PSS',
                        hash: 'SHA-256',
                    },
                    false,
                    ['verify']
                );

                // Verify the signature
                const encoder = new TextEncoder();
                const dataBuffer = encoder.encode(signedDataStr);
                const signatureBuffer = Uint8Array.from(atob(signature), c => c.charCodeAt(0));

                return await crypto.subtle.verify(
                    {
                        name: 'RSA-PSS',
                        saltLength: 32, // 256 bits for SHA-256
                    },
                    publicKeyObj,
                    signatureBuffer,
                    dataBuffer
                );
            } catch (error) {
                console.error('Signature verification error:', error);
                return false;
            }
        }

        // Add generateTextHash to global scope for legacy verification
        async function generateTextHash(text) {
            const encoder = new TextEncoder();
            const data = encoder.encode(text.trim());
            const hashBuffer = await crypto.subtle.digest('SHA-256', data);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
        }

        // Add reconstructText to global scope for legacy verification
        function reconstructText(log) {
            let text = '';

            for (const entry of log) {
                if (entry.type === 'diff' && entry.change) {
                    if (entry.change.added) {
                        // Insert text at position
                        const pos = entry.change.pos || text.length;
                        text = text.slice(0, pos) + entry.change.added + text.slice(pos);
                    } else if (entry.change.removed) {
                        // Remove text from position
                        const pos = entry.change.pos || 0;
                        const removeLength = entry.change.removed.length;
                        text = text.slice(0, pos) + text.slice(pos + removeLength);
                    }
                }
            }

            return text;
        }

        // Make functions available globally
        window.verifySignature = verifySignature;
        window.generateTextHash = generateTextHash;
        window.reconstructText = reconstructText;
    </script>
    <script src="hav-verify.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
        }
        .section {
            margin-bottom: 25px;
        }
        .section h2 {
            color: #555;
            font-size: 18px;
            margin-bottom: 10px;
        }
        textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-family: monospace;
            font-size: 14px;
            resize: vertical;
        }
        textarea:focus {
            border-color: #4CAF50;
            outline: none;
        }
        button {
            background-color: #4CAF50;
            color: white;
            padding: 12px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin: 5px;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #45a049;
        }
        button.secondary {
            background-color: #2196F3;
        }
        button.secondary:hover {
            background-color: #0b7dda;
        }
        button.danger {
            background-color: #f44336;
        }
        button.danger:hover {
            background-color: #da190b;
        }
        .button-group {
            text-align: center;
            margin: 20px 0;
        }
        .status-message {
            padding: 10px;
            background-color: #e8f5e8;
            border-radius: 5px;
            margin: 10px 0;
        }
        .status-error {
            background-color: #ffebee;
            color: #c62828;
        }
        .status-warning {
            background-color: #fff3e0;
            color: #ef6c00;
        }
        .verification-result {
            background-color: #f8f9fa;
            padding: 20px;
            border-radius: 5px;
            border: 1px solid #dee2e6;
            margin: 20px 0;
        }
        .result-valid {
            border-color: #28a745;
            background-color: #d4edda;
        }
        .result-invalid {
            border-color: #dc3545;
            background-color: #f8d7da;
        }
        .result-details {
            margin: 10px 0;
        }
        .result-details strong {
            display: inline-block;
            width: 150px;
        }
        .badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
        }
        .badge-valid {
            background-color: #28a745;
            color: white;
        }
        .badge-invalid {
            background-color: #dc3545;
            color: white;
        }
        .badge-warning {
            background-color: #ffc107;
            color: #212529;
        }
        .tabs {
            display: flex;
            margin-bottom: 20px;
        }
        .tab {
            padding: 10px 20px;
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            cursor: pointer;
            border-bottom: none;
        }
        .tab.active {
            background-color: white;
            border-bottom: 2px solid #4CAF50;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        .url-input {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .url-input input {
            flex: 1;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 5px;
        }
        .batch-results {
            max-height: 400px;
            overflow-y: auto;
        }
        .batch-item {
            padding: 10px;
            margin: 5px 0;
            border-radius: 5px;
            border: 1px solid #ddd;
        }
        .batch-item.valid {
            background-color: #d4edda;
            border-color: #28a745;
        }
        .batch-item.invalid {
            background-color: #f8d7da;
            border-color: #dc3545;
        }
        .loading {
            text-align: center;
            padding: 20px;
        }
        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #4CAF50;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .level-badge {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 11px;
            font-weight: bold;
            margin-right: 8px;
        }
        .level-badge.level-1 {
            background-color: #4CAF50;
            color: white;
        }
        .level-badge.level-2 {
            background-color: #2196F3;
            color: white;
        }
        .level-result {
            margin-bottom: 20px;
        }
        .level-result h4 {
            margin: 0 0 10px 0;
            color: #333;
            font-size: 16px;
        }
        .verifying {
            color: #ff9800;
            font-style: italic;
            font-size: 14px;
        }
        .two-tier-results {
            margin: 20px 0;
            padding: 20px;
            background-color: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #dee2e6;
        }
        .two-tier-results h3 {
            margin-top: 0;
            color: #333;
            border-bottom: 2px solid #4CAF50;
            padding-bottom: 8px;
        }
        .combined-status {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid #dee2e6;
        }
        .combined-status h4 {
            color: #333;
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script>
        // React App Component
        const { useState, useEffect } = React;

        function App() {
            const [activeTab, setActiveTab] = useState('single');
            const [input, setInput] = useState('');
            const [url, setUrl] = useState('');
            const [logData, setLogData] = useState('');
            const [useLocalLog, setUseLocalLog] = useState(false);
            const [isVerifying, setIsVerifying] = useState(false);
            const [result, setResult] = useState(null);
            const [batchResults, setBatchResults] = useState([]);

            // Two-tier verification states
            const [level1Result, setLevel1Result] = useState(null);
            const [level2Result, setLevel2Result] = useState(null);
            const [isVerifyingLevel1, setIsVerifyingLevel1] = useState(false);
            const [isVerifyingLevel2, setIsVerifyingLevel2] = useState(false);

            // Check for pre-populated data from main page
            useEffect(() => {
                const storedHtml = sessionStorage.getItem('hav-html-to-verify');
                const storedLog = sessionStorage.getItem('hav-log-to-verify');

                if (storedHtml) {
                    setInput(storedHtml);
                    setUseLocalLog(true);
                    // Clear the stored data after using it
                    sessionStorage.removeItem('hav-html-to-verify');
                }

                if (storedLog) {
                    setLogData(storedLog);
                    // Clear the stored data after using it
                    sessionStorage.removeItem('hav-log-to-verify');
                }
            }, []);

            // Reactive Level 1 verification
            useEffect(() => {
                const performLevel1Verification = async () => {
                    if (!input.trim()) {
                        setLevel1Result(null);
                        return;
                    }

                    setIsVerifyingLevel1(true);
                    try {
                        const parser = new DOMParser();
                        const doc = parser.parseFromString(input, 'text/html');
                        const element = doc.querySelector('[data-hav-key]');

                        if (!element) {
                            setLevel1Result({ isValid: false, details: { errors: ['No element with authorship data found'] } });
                            return;
                        }

                        const publicKeyStr = element.getAttribute('data-hav-key');
                        const contentSignature = element.getAttribute('data-hav-content-signature');
                        const logSignature = element.getAttribute('data-hav-log-signature');
                        const timestamp = parseInt(element.getAttribute('data-hav-timestamp'));

                        if (!publicKeyStr || !contentSignature || !timestamp) {
                            setLevel1Result({
                                isValid: false,
                                details: { errors: ['Missing Level 1 verification data (public key, content signature, or timestamp)'] }
                            });
                            return;
                        }

                        // Parse public key
                        let decodedKeyStr = publicKeyStr;
                        try {
                            decodedKeyStr = atob(publicKeyStr);
                        } catch (e) {
                            // If base64 decode fails, assume it's already plain JSON
                        }
                        const publicKey = JSON.parse(decodedKeyStr);

                        // Extract text content
                        const text = element.textContent?.trim() || '';

                        // Only support two-tier format now
                        if (window.HAVCore && window.HAVCore.verifyContent) {
                            try {
                                const result = await window.HAVCore.verifyContent(text, contentSignature, timestamp, publicKey);
                                setLevel1Result(result);
                            } catch (error) {
                                setLevel1Result({
                                    isValid: false,
                                    details: { errors: [`Level 1 verification error: ${error.message}`] }
                                });
                            }
                        } else {
                            setLevel1Result({
                                isValid: false,
                                details: { errors: ['HAVCore not available for Level 1 verification'] }
                            });
                        }
                    } catch (error) {
                        setLevel1Result({
                            isValid: false,
                            details: { errors: [`Level 1 verification error: ${error.message}`] }
                        });
                    }
                    setIsVerifyingLevel1(false);
                };

                performLevel1Verification();
            }, [input]);

            // Reactive Level 2 verification
            useEffect(() => {
                const performLevel2Verification = async () => {
                    if (!input.trim() || !useLocalLog || !logData.trim()) {
                        setLevel2Result(null);
                        return;
                    }

                    setIsVerifyingLevel2(true);
                    try {
                        const parser = new DOMParser();
                        const doc = parser.parseFromString(input, 'text/html');
                        const element = doc.querySelector('[data-hav-key]');

                        if (!element) {
                            setLevel2Result({ isValid: false, details: { errors: ['No element with authorship data found'] } });
                            return;
                        }

                        const publicKeyStr = element.getAttribute('data-hav-key');
                        const contentSignature = element.getAttribute('data-hav-content-signature');
                        const logSignature = element.getAttribute('data-hav-log-signature');
                        const timestamp = parseInt(element.getAttribute('data-hav-timestamp'));

                        if (!publicKeyStr || !logSignature || !timestamp) {
                            setLevel2Result({
                                isValid: false,
                                details: { errors: ['Missing Level 2 verification data (public key, log signature, or timestamp)'] }
                            });
                            return;
                        }

                        // Parse public key
                        let decodedKeyStr = publicKeyStr;
                        try {
                            decodedKeyStr = atob(publicKeyStr);
                        } catch (e) {
                            // If base64 decode fails, assume it's already plain JSON
                        }
                        const publicKey = JSON.parse(decodedKeyStr);

                        // Parse log data
                        const logDataObj = JSON.parse(logData);

                        // Extract text content
                        const text = element.textContent?.trim() || '';

                        // Only support two-tier format now
                        if (window.HAVCore && window.HAVCore.verifyLogSignature) {
                            console.log('Level 2 Verification Debug:');
                            console.log('Text:', text);
                            console.log('Log:', logDataObj.log);
                            console.log('LogSignature:', logSignature);
                            console.log('Timestamp:', timestamp);
                            console.log('SignedData:', logDataObj);

                            const result = await window.HAVCore.verifyLogSignature(logDataObj.log, text, logSignature, timestamp, publicKey);
                            console.log('Verification result:', result);
                            setLevel2Result(result);
                        } else {
                            setLevel2Result({
                                isValid: false,
                                details: { errors: ['HAVCore not available for Level 2 verification'] }
                            });
                        }
                    } catch (error) {
                        setLevel2Result({
                            isValid: false,
                            details: { errors: [`Level 2 verification error: ${error.message}`] }
                        });
                    }
                    setIsVerifyingLevel2(false);
                };

                performLevel2Verification();
            }, [input, useLocalLog, logData]);
            const verifySingle = async () => {
                if (!input.trim()) {
                    alert('Please enter HTML to verify');
                    return;
                }

                if (useLocalLog && !logData.trim()) {
                    alert('Please provide log data or uncheck "Use local log data"');
                    return;
                }

                setIsVerifying(true);
                setResult(null);

                try {
                    if (useLocalLog) {
                        // Manual verification with local log data
                        const parser = new DOMParser();
                        const doc = parser.parseFromString(input, 'text/html');
                        const element = doc.querySelector('[data-hav-key]');

                        if (!element) {
                            throw new Error('No element with authorship data found');
                        }

                        // Extract data attributes
                        const publicKeyStr = element.getAttribute('data-hav-key');
                        const signature = element.getAttribute('data-hav-signature');

                        if (!publicKeyStr || !signature) {
                            throw new Error('Missing required authorship attributes');
                        }

                        // Parse public key (base64 decode first, then JSON parse)
                        let decodedKeyStr = publicKeyStr;
                        try {
                            decodedKeyStr = atob(publicKeyStr);
                        } catch (e) {
                            // If base64 decode fails, assume it's already plain JSON
                        }
                        const publicKey = JSON.parse(decodedKeyStr);

                        // Use provided log data
                        const logDataObj = JSON.parse(logData);

                        // Extract text content
                        const text = element.textContent?.trim() || '';

                        // Verify using built-in function
                        const verificationResult = await verifyLog(logDataObj.log, text, signature, publicKey, logDataObj);
                        setResult({
                            isValid: verificationResult.isValid,
                            details: {
                                signatureValid: verificationResult.details.signatureValid,
                                textMatches: verificationResult.details.textMatches,
                                logAccessible: true, // Since we're using local data
                                fingerprint: null,
                                reconstructedText: verificationResult.details.reconstructedText,
                                errors: verificationResult.details.errors,
                                warnings: verificationResult.details.warnings
                            }
                        });
                    } else {
                        // Use HumanAuthorshipVerifier for verification
                        const verifier = new HumanAuthorshipVerifier();
                        const verificationResult = await verifier.verify(input);
                        setResult(verificationResult);
                    }
                } catch (error) {
                    setResult({
                        isValid: false,
                        details: {
                            errors: [`Verification failed: ${error.message}`],
                            warnings: []
                        }
                    });
                }

                setIsVerifying(false);
            };

            const verifyFromUrl = async () => {
                if (!url.trim()) {
                    alert('Please enter a URL');
                    return;
                }

                setIsVerifying(true);
                setResult(null);

                try {
                    const response = await fetch(url);
                    if (!response.ok) {
                        throw new Error(`Failed to fetch URL: ${response.status}`);
                    }
                    const html = await response.text();

                    // Use HumanAuthorshipVerifier for verification
                    const verifier = new HumanAuthorshipVerifier();
                    const verificationResult = await verifier.verify(html);
                    setResult(verificationResult);
                } catch (error) {
                    setResult({
                        isValid: false,
                        details: {
                            errors: [`Verification failed: ${error.message}`],
                            warnings: []
                        }
                    });
                }

                setIsVerifying(false);
            };

            const verifyBatch = async () => {
                if (!input.trim()) {
                    alert('Please enter HTML containing multiple elements to verify');
                    return;
                }

                setIsVerifying(true);
                setBatchResults([]);

                try {
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(input, 'text/html');
                    const elements = Array.from(doc.querySelectorAll('[data-hav-key]'));

                    if (elements.length === 0) {
                        alert('No elements with authorship data found');
                        setIsVerifying(false);
                        return;
                    }

                    // Use HumanAuthorshipVerifier for batch verification
                    const verifier = new HumanAuthorshipVerifier();
                    const results = await verifier.verifyBatch(elements);
                    setBatchResults(results);
                } catch (error) {
                    setBatchResults([{
                        element: null,
                        success: false,
                        result: null,
                        error: error.message
                    }]);
                }

                setIsVerifying(false);
            };

            const clearAll = () => {
                setInput('');
                setUrl('');
                setLogData('');
                setUseLocalLog(false);
                setResult(null);
                setBatchResults([]);
                setLevel1Result(null);
                setLevel2Result(null);
            };

            const renderTwoTierResults = () => {
                if (!level1Result && !level2Result) return null;

                return React.createElement('div', { className: 'two-tier-results' },
                    React.createElement('h3', null, 'Two-Tier Verification Results'),

                    // Level 1 Result
                    React.createElement('div', { className: 'level-result' },
                        React.createElement('h4', null,
                            React.createElement('span', { className: 'level-badge level-1' }, 'Level 1'),
                            ' Content Integrity Check ',
                            isVerifyingLevel1 && React.createElement('span', { className: 'verifying' }, '(verifying...)')
                        ),
                        level1Result && React.createElement('div', { className: `verification-result ${level1Result.isValid ? 'result-valid' : 'result-invalid'}` },
                            React.createElement('p', null,
                                React.createElement('strong', null, 'Status:'),
                                React.createElement('span', { className: `badge ${level1Result.isValid ? 'badge-valid' : 'badge-invalid'}` },
                                    level1Result.isValid ? '✓ TEXT INTEGRITY VERIFIED' : '✗ TEXT TAMPERED'
                                )
                            ),
                            React.createElement('p', null,
                                React.createElement('strong', null, 'Content Signature:'),
                                React.createElement('span', { className: `badge ${level1Result.details.contentSignatureValid ? 'badge-valid' : 'badge-invalid'}` },
                                    level1Result.details.contentSignatureValid ? 'VALID' : 'INVALID'
                                )
                            ),
                            (level1Result.details.errors && level1Result.details.errors.length > 0) && React.createElement('div', { className: 'status-message status-error' },
                                React.createElement('strong', null, 'Errors:'),
                                React.createElement('ul', null,
                                    level1Result.details.errors.map((error, index) =>
                                        React.createElement('li', { key: index }, error)
                                    )
                                )
                            ),
                            (level1Result.details.warnings && level1Result.details.warnings.length > 0) && React.createElement('div', { className: 'status-message status-warning' },
                                React.createElement('strong', null, 'Warnings:'),
                                React.createElement('ul', null,
                                    level1Result.details.warnings.map((warning, index) =>
                                        React.createElement('li', { key: index }, warning)
                                    )
                                )
                            )
                        )
                    ),

                    // Level 2 Result
                    useLocalLog && React.createElement('div', { className: 'level-result' },
                        React.createElement('h4', null,
                            React.createElement('span', { className: 'level-badge level-2' }, 'Level 2'),
                            ' Behavioral Verification ',
                            isVerifyingLevel2 && React.createElement('span', { className: 'verifying' }, '(verifying...)')
                        ),
                        level2Result && React.createElement('div', { className: `verification-result ${level2Result.isValid ? 'result-valid' : 'result-invalid'}` },
                            React.createElement('p', null,
                                React.createElement('strong', null, 'Status:'),
                                React.createElement('span', { className: `badge ${level2Result.isValid ? 'badge-valid' : 'badge-invalid'}` },
                                    level2Result.isValid ? '✓ HUMAN AUTHORSHIP VERIFIED' : '✗ VERIFICATION FAILED'
                                )
                            ),
                            React.createElement('p', null,
                                React.createElement('strong', null, 'Log Signature:'),
                                React.createElement('span', { className: `badge ${level2Result.details.logSignatureValid ? 'badge-valid' : 'badge-invalid'}` },
                                    level2Result.details.logSignatureValid ? 'VALID' : 'INVALID'
                                )
                            ),
                            React.createElement('p', null,
                                React.createElement('strong', null, 'Text Matches Log:'),
                                React.createElement('span', { className: `badge ${level2Result.details.textMatches ? 'badge-valid' : 'badge-invalid'}` },
                                    level2Result.details.textMatches ? 'YES' : 'NO'
                                )
                            ),
                            level2Result.details.reconstructedText && React.createElement('p', null,
                                React.createElement('strong', null, 'Reconstructed Text:'),
                                React.createElement('br', null),
                                React.createElement('em', null, `"${level2Result.details.reconstructedText}"`)
                            ),
                            (level2Result.details.errors && level2Result.details.errors.length > 0) && React.createElement('div', { className: 'status-message status-error' },
                                React.createElement('strong', null, 'Errors:'),
                                React.createElement('ul', null,
                                    level2Result.details.errors.map((error, index) =>
                                        React.createElement('li', { key: index }, error)
                                    )
                                )
                            ),
                            (level2Result.details.warnings && level2Result.details.warnings.length > 0) && React.createElement('div', { className: 'status-message status-warning' },
                                React.createElement('strong', null, 'Warnings:'),
                                React.createElement('ul', null,
                                    level2Result.details.warnings.map((warning, index) =>
                                        React.createElement('li', { key: index }, warning)
                                    )
                                )
                            )
                        ),
                        !level2Result && !isVerifyingLevel2 && React.createElement('div', { className: 'verification-result' },
                            React.createElement('p', { style: { color: '#666', fontStyle: 'italic' } }, 'Provide log data above to enable Level 2 verification')
                        )
                    ),

                    // Combined Status
                    level1Result && (!useLocalLog || level2Result) && React.createElement('div', { className: 'combined-status' },
                        React.createElement('h4', null, 'Combined Verification Status'),
                        React.createElement('div', { className: `verification-result ${(level1Result.isValid && (!useLocalLog || level2Result?.isValid)) ? 'result-valid' : 'result-invalid'}` },
                            React.createElement('p', null,
                                React.createElement('strong', null, 'Overall Status:'),
                                React.createElement('span', { className: `badge ${(level1Result.isValid && (!useLocalLog || level2Result?.isValid)) ? 'badge-valid' : 'badge-invalid'}` },
                                    (level1Result.isValid && (!useLocalLog || level2Result?.isValid)) ? '✓ VERIFICATION PASSED' : '✗ VERIFICATION FAILED'
                                )
                            ),
                            React.createElement('p', null, 'Level 1 (Content): ', level1Result.isValid ? '✅ Passed' : '❌ Failed'),
                            useLocalLog && React.createElement('p', null, 'Level 2 (Behavioral): ', level2Result?.isValid ? '✅ Passed' : '❌ Failed')
                        )
                    )
                );
            };

            const renderResult = (result) => {
                if (!result) return null;

                const statusClass = result.isValid ? 'result-valid' : 'result-invalid';
                const statusText = result.isValid ? '✓ VERIFIED' : '✗ NOT VERIFIED';

                return React.createElement('div', { className: `verification-result ${statusClass}` },
                    React.createElement('h3', null, statusText),
                    React.createElement('div', { className: 'result-details' },
                        React.createElement('p', null,
                            React.createElement('strong', null, 'Signature Valid:'),
                            React.createElement('span', { className: `badge ${result.details.signatureValid ? 'badge-valid' : 'badge-invalid'}` },
                                result.details.signatureValid ? 'YES' : 'NO'
                            )
                        ),
                        React.createElement('p', null,
                            React.createElement('strong', null, 'Text Matches:'),
                            React.createElement('span', { className: `badge ${result.details.textMatches ? 'badge-valid' : 'badge-invalid'}` },
                                result.details.textMatches ? 'YES' : 'NO'
                            )
                        ),
                        React.createElement('p', null,
                            React.createElement('strong', null, 'Log Accessible:'),
                            React.createElement('span', { className: `badge ${result.details.logAccessible ? 'badge-valid' : 'badge-invalid'}` },
                                result.details.logAccessible ? 'YES' : 'NO'
                            )
                        ),
                        result.details.fingerprint && React.createElement('p', null,
                            React.createElement('strong', null, 'Fingerprint:'),
                            React.createElement('code', null, result.details.fingerprint.substring(0, 16) + '...')
                        ),
                        result.details.reconstructedText && React.createElement('p', null,
                            React.createElement('strong', null, 'Reconstructed Text:'),
                            React.createElement('br', null),
                            React.createElement('em', null, `"${result.details.reconstructedText}"`)
                        )
                    ),
                    (result.details.errors && result.details.errors.length > 0) && React.createElement('div', { className: 'status-message status-error' },
                        React.createElement('strong', null, 'Errors:'),
                        React.createElement('ul', null,
                            result.details.errors.map((error, index) =>
                                React.createElement('li', { key: index }, error)
                            )
                        )
                    ),
                    (result.details.warnings && result.details.warnings.length > 0) && React.createElement('div', { className: 'status-message status-warning' },
                        React.createElement('strong', null, 'Warnings:'),
                        React.createElement('ul', null,
                            result.details.warnings.map((warning, index) =>
                                React.createElement('li', { key: index }, warning)
                            )
                        )
                    )
                );
            };

            const renderBatchResults = () => {
                if (batchResults.length === 0) return null;

                return React.createElement('div', { className: 'batch-results' },
                    React.createElement('h3', null, `Batch Results (${batchResults.length} items)`),
                    batchResults.map((item, index) => {
                        const statusClass = item.success && item.result?.isValid ? 'valid' : 'invalid';
                        const statusText = item.success && item.result?.isValid ? '✓ Verified' : '✗ Failed';

                        return React.createElement('div', { key: index, className: `batch-item ${statusClass}` },
                            React.createElement('strong', null, `Item ${index + 1}: ${statusText}`),
                            item.success ? renderResult(item.result) : React.createElement('p', null, `Error: ${item.error}`)
                        );
                    })
                );
            };

            return React.createElement('div', { className: 'container' },
                React.createElement('h1', null, 'Human Authorship Verifier'),

                // Tabs
                React.createElement('div', { className: 'tabs' },
                    React.createElement('div', {
                        className: `tab ${activeTab === 'single' ? 'active' : ''}`,
                        onClick: () => setActiveTab('single')
                    }, 'Single Verification'),
                    React.createElement('div', {
                        className: `tab ${activeTab === 'url' ? 'active' : ''}`,
                        onClick: () => setActiveTab('url')
                    }, 'Verify from URL'),
                    React.createElement('div', {
                        className: `tab ${activeTab === 'batch' ? 'active' : ''}`,
                        onClick: () => setActiveTab('batch')
                    }, 'Batch Verification')
                ),

                // Single Verification Tab
                React.createElement('div', { className: `tab-content ${activeTab === 'single' ? 'active' : ''}` },
                    React.createElement('div', { className: 'section' },
                        React.createElement('h2', null, 'Paste HTML to Verify'),
                        React.createElement('textarea', {
                            value: input,
                            onChange: (e) => setInput(e.target.value),
                            placeholder: 'Paste HTML containing data-hav-* attributes here...',
                            rows: 8
                        })
                    ),
                    React.createElement('div', { className: 'section' },
                        React.createElement('label', { style: { display: 'flex', alignItems: 'center', gap: '10px' } },
                            React.createElement('input', {
                                type: 'checkbox',
                                checked: useLocalLog,
                                onChange: (e) => setUseLocalLog(e.target.checked)
                            }),
                            React.createElement('span', null, 'Use local log data instead of fetching from URL')
                        ),
                        useLocalLog && React.createElement('div', { style: { marginTop: '10px' } },
                            React.createElement('h3', null, 'Event Log JSON'),
                            React.createElement('textarea', {
                                value: logData,
                                onChange: (e) => setLogData(e.target.value),
                                placeholder: 'Paste the eventlog.json content here...',
                                rows: 6
                            }),
                            React.createElement('div', { style: { marginTop: '10px' } },
                                React.createElement('button', {
                                    className: 'secondary',
                                    onClick: async () => {
                                        if (!logData.trim()) {
                                            alert('No log data to copy');
                                            return;
                                        }
                                        try {
                                            if (navigator.clipboard && window.isSecureContext) {
                                                await navigator.clipboard.writeText(logData);
                                                alert('Event log copied to clipboard!');
                                            } else {
                                                // Fallback
                                                const tempTextArea = document.createElement('textarea');
                                                tempTextArea.value = logData;
                                                document.body.appendChild(tempTextArea);
                                                tempTextArea.select();
                                                document.execCommand('copy');
                                                document.body.removeChild(tempTextArea);
                                                alert('Event log copied to clipboard!');
                                            }
                                        } catch (error) {
                                            alert('Failed to copy: ' + error.message);
                                        }
                                    }
                                }, 'Copy Event Log to Clipboard')
                            )
                        )
                    ),
                    React.createElement('div', { className: 'button-group' },
                        React.createElement('button', {
                            onClick: verifySingle,
                            disabled: isVerifying
                        }, isVerifying ? 'Verifying...' : 'Verify Authorship'),
                        React.createElement('button', { className: 'danger', onClick: clearAll }, 'Clear All')
                    ),
                    isVerifying && React.createElement('div', { className: 'loading' },
                        React.createElement('div', { className: 'spinner' }),
                        React.createElement('p', null, 'Verifying authorship...')
                    ),
                    renderTwoTierResults(),
                    result && renderResult(result)
                ),

                // URL Verification Tab
                React.createElement('div', { className: `tab-content ${activeTab === 'url' ? 'active' : ''}` },
                    React.createElement('div', { className: 'section' },
                        React.createElement('h2', null, 'Verify from URL'),
                        React.createElement('div', { className: 'url-input' },
                            React.createElement('input', {
                                type: 'url',
                                value: url,
                                onChange: (e) => setUrl(e.target.value),
                                placeholder: 'https://example.com/page.html'
                            }),
                            React.createElement('button', {
                                onClick: verifyFromUrl,
                                disabled: isVerifying
                            }, isVerifying ? 'Loading...' : 'Verify')
                        )
                    ),
                    isVerifying && React.createElement('div', { className: 'loading' },
                        React.createElement('div', { className: 'spinner' }),
                        React.createElement('p', null, 'Fetching and verifying...')
                    ),
                    result && renderResult(result)
                ),

                // Batch Verification Tab
                React.createElement('div', { className: `tab-content ${activeTab === 'batch' ? 'active' : ''}` },
                    React.createElement('div', { className: 'section' },
                        React.createElement('h2', null, 'Batch Verification'),
                        React.createElement('p', null, 'Paste HTML containing multiple elements with authorship data to verify them all at once.'),
                        React.createElement('textarea', {
                            value: input,
                            onChange: (e) => setInput(e.target.value),
                            placeholder: 'Paste HTML with multiple data-hav-* elements...',
                            rows: 8
                        })
                    ),
                    React.createElement('div', { className: 'button-group' },
                        React.createElement('button', {
                            onClick: verifyBatch,
                            disabled: isVerifying
                        }, isVerifying ? 'Verifying...' : 'Verify Batch'),
                        React.createElement('button', { className: 'danger', onClick: clearAll }, 'Clear All')
                    ),
                    isVerifying && React.createElement('div', { className: 'loading' },
                        React.createElement('div', { className: 'spinner' }),
                        React.createElement('p', null, 'Verifying batch...')
                    ),
                    renderBatchResults()
                )
            );
        }

        // Render the app
        ReactDOM.render(React.createElement(App), document.getElementById('root'));
    </script>
</body>
</html>
