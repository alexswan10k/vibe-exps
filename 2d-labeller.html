<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image Labelling Tool</title>
    <style>
body {
    font-family: Arial, sans-serif;
    margin: 0;
    padding: 0;
    background-color: #f5f5f5;
    color: #333;
    height: 100vh;
    overflow: hidden;
}

.container {
    display: flex;
    height: 100vh;
}

.image-panel {
    flex: 1;
    background-color: #fff;
    display: flex;
    align-items: center;
    justify-content: center;
    border-right: 1px solid #ddd;
}

.image-panel h2 {
    color: #999;
}

.label-panel {
    width: 300px;
    background-color: #fafafa;
    padding: 20px;
    box-sizing: border-box;
    border-left: 1px solid #ddd;
}

.label-panel h2 {
    margin-top: 0;
    font-size: 18px;
    color: #555;
}

.label-list {
    list-style: none;
    padding: 0;
}

.label-item {
    padding: 10px;
    margin-bottom: 10px;
    background-color: #fff;
    border: 1px solid #ddd;
    border-radius: 4px;
    cursor: pointer;
}

.label-item:hover {
    background-color: #f0f0f0;
}

.label-item.selected {
    background-color: #ddd;
}
    </style>
    <!-- React from CDN -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
</head>
<body>
    <div id="root"></div>

    <script type="text/javascript">
const App = () => {
    const [image, setImage] = React.useState(null);
    const [boundingBoxes, setBoundingBoxes] = React.useState([]);
    const canvasRef = React.useRef(null);
    const [isDrawing, setIsDrawing] = React.useState(false);
    const [startPos, setStartPos] = React.useState({x: 0, y: 0});
    const [currentBox, setCurrentBox] = React.useState(null);
    const [dragging, setDragging] = React.useState(false);
    const [resizing, setResizing] = React.useState(false);
    const [resizeHandle, setResizeHandle] = React.useState(null);
    const [selectedBoxIndex, setSelectedBoxIndex] = React.useState(null);
    const [isAddingBox, setIsAddingBox] = React.useState(false);
    const [labelInput, setLabelInput] = React.useState('');
    const jsonFileRef = React.useRef(null);
    const loadClassesFromStorage = () => {
        try {
            const stored = localStorage.getItem('imageLabellerClasses');
            if (stored) {
                return JSON.parse(stored);
            }
        } catch (e) {
            console.warn('Failed to load classes from storage:', e);
        }
        return [{id: 0, name: 'object'}];
    };

    const saveClassesToStorage = (classes) => {
        try {
            localStorage.setItem('imageLabellerClasses', JSON.stringify(classes));
        } catch (e) {
            console.warn('Failed to save classes to storage:', e);
        }
    };

    const [classes, setClasses] = React.useState(loadClassesFromStorage());
    const [nextClassId, setNextClassId] = React.useState(() => {
        const stored = loadClassesFromStorage();
        return Math.max(...stored.map(c => c.id), 0) + 1;
    });
    const [classesCollapsed, setClassesCollapsed] = React.useState(true);
    const [editingClassId, setEditingClassId] = React.useState(null);
    const [editingClassName, setEditingClassName] = React.useState('');

    const validateImageFile = (file) => {
        const validTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/bmp', 'image/webp'];
        return validTypes.includes(file.type);
    };

    const loadImage = (file) => {
        if (!validateImageFile(file)) {
            alert('Please select a valid image file.');
            return;
        }
        const reader = new FileReader();
        reader.onload = (e) => {
            const img = new Image();
            img.onload = () => {
                setImage(img);
            };
            img.src = e.target.result;
        };
        reader.readAsDataURL(file);
    };

    const drawImageOnCanvas = (img) => {
        const canvas = canvasRef.current;
        if (!canvas) return;
        const ctx = canvas.getContext('2d');
        const maxWidth = canvas.width;
        const maxHeight = canvas.height;
        const imgAspect = img.width / img.height;
        const canvasAspect = maxWidth / maxHeight;
        let drawWidth, drawHeight, offsetX, offsetY;

        if (imgAspect > canvasAspect) {
            drawWidth = maxWidth;
            drawHeight = maxWidth / imgAspect;
            offsetX = 0;
            offsetY = (maxHeight - drawHeight) / 2;
        } else {
            drawHeight = maxHeight;
            drawWidth = maxHeight * imgAspect;
            offsetX = (maxWidth - drawWidth) / 2;
            offsetY = 0;
        }

        ctx.clearRect(0, 0, maxWidth, maxHeight);
        ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);
        drawBoundingBoxes(ctx, offsetX, offsetY, drawWidth, drawHeight, img.width, img.height);
    };

    const drawBoundingBoxes = (ctx, offsetX, offsetY, drawWidth, drawHeight, imgWidth, imgHeight) => {
        boundingBoxes.forEach((box, index) => {
            const scaleX = drawWidth / imgWidth;
            const scaleY = drawHeight / imgHeight;
            const x = offsetX + box.x * scaleX;
            const y = offsetY + box.y * scaleY;
            const width = box.width * scaleX;
            const height = box.height * scaleY;

            ctx.strokeStyle = index === selectedBoxIndex ? '#ff0000' : '#00ff00';
            ctx.lineWidth = index === selectedBoxIndex ? 3 : 2;
            ctx.strokeRect(x, y, width, height);

            if (index === selectedBoxIndex) {
                // Draw resize handles
                const handleSize = 6;
                ctx.fillStyle = '#ff0000';
                // Corners
                ctx.fillRect(x - handleSize/2, y - handleSize/2, handleSize, handleSize);
                ctx.fillRect(x + width - handleSize/2, y - handleSize/2, handleSize, handleSize);
                ctx.fillRect(x - handleSize/2, y + height - handleSize/2, handleSize, handleSize);
                ctx.fillRect(x + width - handleSize/2, y + height - handleSize/2, handleSize, handleSize);
                // Midpoints
                ctx.fillRect(x + width/2 - handleSize/2, y - handleSize/2, handleSize, handleSize);
                ctx.fillRect(x + width/2 - handleSize/2, y + height - handleSize/2, handleSize, handleSize);
                ctx.fillRect(x - handleSize/2, y + height/2 - handleSize/2, handleSize, handleSize);
                ctx.fillRect(x + width - handleSize/2, y + height/2 - handleSize/2, handleSize, handleSize);
            }

            // Draw label
            ctx.fillStyle = '#00ff00';
            ctx.font = '12px Arial';
            const labelWidth = ctx.measureText(box.label).width;
            ctx.fillRect(x, y - 20, labelWidth + 4, 16);
            ctx.fillStyle = '#000';
            ctx.fillText(box.label, x + 2, y - 8);
        });
    };

    const getMousePos = (canvas, e) => {
        const rect = canvas.getBoundingClientRect();
        return {
            x: e.clientX - rect.left,
            y: e.clientY - rect.top
        };
    };

    const getImageCoords = (canvasX, canvasY, offsetX, offsetY, drawWidth, drawHeight, imgWidth, imgHeight) => {
        const scaleX = imgWidth / drawWidth;
        const scaleY = imgHeight / drawHeight;
        return {
            x: (canvasX - offsetX) * scaleX,
            y: (canvasY - offsetY) * scaleY
        };
    };

    const handleMouseDown = (e) => {
        const canvas = canvasRef.current;
        if (!canvas || !image) return;
        const mousePos = getMousePos(canvas, e);
        const ctx = canvas.getContext('2d');
        const maxWidth = canvas.width;
        const maxHeight = canvas.height;
        const imgAspect = image.width / image.height;
        const canvasAspect = maxWidth / maxHeight;
        let drawWidth, drawHeight, offsetX, offsetY;

        if (imgAspect > canvasAspect) {
            drawWidth = maxWidth;
            drawHeight = maxWidth / imgAspect;
            offsetX = 0;
            offsetY = (maxHeight - drawHeight) / 2;
        } else {
            drawHeight = maxHeight;
            drawWidth = maxHeight * imgAspect;
            offsetX = (maxWidth - drawWidth) / 2;
            offsetY = 0;
        }

        const imgCoords = getImageCoords(mousePos.x, mousePos.y, offsetX, offsetY, drawWidth, drawHeight, image.width, image.height);

        // Check if clicking on a resize handle
        if (selectedBoxIndex !== null) {
            const box = boundingBoxes[selectedBoxIndex];
            const scaleX = drawWidth / image.width;
            const scaleY = drawHeight / image.height;
            const x = offsetX + box.x * scaleX;
            const y = offsetY + box.y * scaleY;
            const width = box.width * scaleX;
            const height = box.height * scaleY;
            const handleSize = 6;

            if (Math.abs(mousePos.x - x) < handleSize && Math.abs(mousePos.y - y) < handleSize) {
                setResizing(true);
                setResizeHandle('nw');
                return;
            }
            if (Math.abs(mousePos.x - (x + width)) < handleSize && Math.abs(mousePos.y - y) < handleSize) {
                setResizing(true);
                setResizeHandle('ne');
                return;
            }
            if (Math.abs(mousePos.x - x) < handleSize && Math.abs(mousePos.y - (y + height)) < handleSize) {
                setResizing(true);
                setResizeHandle('sw');
                return;
            }
            if (Math.abs(mousePos.x - (x + width)) < handleSize && Math.abs(mousePos.y - (y + height)) < handleSize) {
                setResizing(true);
                setResizeHandle('se');
                return;
            }
            // Midpoints
            if (Math.abs(mousePos.x - (x + width/2)) < handleSize && Math.abs(mousePos.y - y) < handleSize) {
                setResizing(true);
                setResizeHandle('n');
                return;
            }
            if (Math.abs(mousePos.x - (x + width/2)) < handleSize && Math.abs(mousePos.y - (y + height)) < handleSize) {
                setResizing(true);
                setResizeHandle('s');
                return;
            }
            if (Math.abs(mousePos.x - x) < handleSize && Math.abs(mousePos.y - (y + height/2)) < handleSize) {
                setResizing(true);
                setResizeHandle('w');
                return;
            }
            if (Math.abs(mousePos.x - (x + width)) < handleSize && Math.abs(mousePos.y - (y + height/2)) < handleSize) {
                setResizing(true);
                setResizeHandle('e');
                return;
            }
        }

        // Check if clicking inside a box
        for (let i = boundingBoxes.length - 1; i >= 0; i--) {
            const box = boundingBoxes[i];
            if (imgCoords.x >= box.x && imgCoords.x <= box.x + box.width &&
                imgCoords.y >= box.y && imgCoords.y <= box.y + box.height) {
                setSelectedBoxIndex(i);
                setDragging(true);
                setStartPos(imgCoords);
                return;
            }
        }

        // Start creating new box if adding
        if (isAddingBox) {
            setSelectedBoxIndex(null);
            setIsDrawing(true);
            setStartPos(imgCoords);
            setCurrentBox({x: imgCoords.x, y: imgCoords.y, width: 0, height: 0, label: ''});
        }
    };

    const handleMouseMove = (e) => {
        const canvas = canvasRef.current;
        if (!canvas || !image) return;
        const mousePos = getMousePos(canvas, e);
        const ctx = canvas.getContext('2d');
        const maxWidth = canvas.width;
        const maxHeight = canvas.height;
        const imgAspect = image.width / image.height;
        const canvasAspect = maxWidth / maxHeight;
        let drawWidth, drawHeight, offsetX, offsetY;

        if (imgAspect > canvasAspect) {
            drawWidth = maxWidth;
            drawHeight = maxWidth / imgAspect;
            offsetX = 0;
            offsetY = (maxHeight - drawHeight) / 2;
        } else {
            drawHeight = maxHeight;
            drawWidth = maxHeight * imgAspect;
            offsetX = (maxWidth - drawWidth) / 2;
            offsetY = 0;
        }

        const imgCoords = getImageCoords(mousePos.x, mousePos.y, offsetX, offsetY, drawWidth, drawHeight, image.width, image.height);

        if (resizing && selectedBoxIndex !== null) {
            const box = boundingBoxes[selectedBoxIndex];
            let newBox = {...box};

            switch (resizeHandle) {
                case 'nw':
                    newBox.width = box.x + box.width - imgCoords.x;
                    newBox.height = box.y + box.height - imgCoords.y;
                    newBox.x = imgCoords.x;
                    newBox.y = imgCoords.y;
                    break;
                case 'ne':
                    newBox.width = imgCoords.x - box.x;
                    newBox.height = box.y + box.height - imgCoords.y;
                    newBox.y = imgCoords.y;
                    break;
                case 'sw':
                    newBox.width = box.x + box.width - imgCoords.x;
                    newBox.height = imgCoords.y - box.y;
                    newBox.x = imgCoords.x;
                    break;
                case 'se':
                    newBox.width = imgCoords.x - box.x;
                    newBox.height = imgCoords.y - box.y;
                    break;
                case 'n':
                    newBox.height = box.y + box.height - imgCoords.y;
                    newBox.y = imgCoords.y;
                    break;
                case 's':
                    newBox.height = imgCoords.y - box.y;
                    break;
                case 'w':
                    newBox.width = box.x + box.width - imgCoords.x;
                    newBox.x = imgCoords.x;
                    break;
                case 'e':
                    newBox.width = imgCoords.x - box.x;
                    break;
            }

            if (newBox.width > 0 && newBox.height > 0) {
                const newBoxes = [...boundingBoxes];
                newBoxes[selectedBoxIndex] = newBox;
                setBoundingBoxes(newBoxes);
            }
        } else if (dragging && selectedBoxIndex !== null) {
            const deltaX = imgCoords.x - startPos.x;
            const deltaY = imgCoords.y - startPos.y;
            const box = boundingBoxes[selectedBoxIndex];
            const newBox = {
                ...box,
                x: box.x + deltaX,
                y: box.y + deltaY
            };
            const newBoxes = [...boundingBoxes];
            newBoxes[selectedBoxIndex] = newBox;
            setBoundingBoxes(newBoxes);
            setStartPos(imgCoords);
        } else if (isDrawing && currentBox) {
            const newBox = {
                ...currentBox,
                width: Math.abs(imgCoords.x - startPos.x),
                height: Math.abs(imgCoords.y - startPos.y),
                x: Math.min(imgCoords.x, startPos.x),
                y: Math.min(imgCoords.y, startPos.y)
            };
            setCurrentBox(newBox);
            // Redraw canvas with current box
            drawImageOnCanvas(image);
            // Draw current box being created
            const scaleX = drawWidth / image.width;
            const scaleY = drawHeight / image.height;
            const x = offsetX + newBox.x * scaleX;
            const y = offsetY + newBox.y * scaleY;
            const width = newBox.width * scaleX;
            const height = newBox.height * scaleY;
            ctx.strokeStyle = '#0000ff';
            ctx.lineWidth = 2;
            ctx.strokeRect(x, y, width, height);
        }
    };

    const handleMouseUp = () => {
        if (isDrawing && currentBox && currentBox.width > 0 && currentBox.height > 0) {
            let label = classes[0].name; // Default to first class
            if (classes.length > 1) {
                // If multiple classes, prompt user to select
                const classNames = classes.map(c => c.name);
                const selectedIndex = prompt(`Select class for the new box:\n${classNames.map((name, i) => `${i}: ${name}`).join('\n')}`, '0');
                if (selectedIndex && !isNaN(selectedIndex) && selectedIndex >= 0 && selectedIndex < classNames.length) {
                    label = classNames[selectedIndex];
                }
            }
            setBoundingBoxes([...boundingBoxes, {...currentBox, label}]);
            setSelectedBoxIndex(boundingBoxes.length);
            setIsAddingBox(false);
        }
        setIsDrawing(false);
        setCurrentBox(null);
        setDragging(false);
        setResizing(false);
        setResizeHandle(null);
    };

    const handleDrop = (e) => {
        e.preventDefault();
        const files = e.dataTransfer.files;
        if (files.length > 0) {
            loadImage(files[0]);
        }
    };

    const handleDragOver = (e) => {
        e.preventDefault();
    };

    const handlePaste = (e) => {
        const items = e.clipboardData.items;
        for (let i = 0; i < items.length; i++) {
            if (items[i].type.indexOf('image') !== -1) {
                const file = items[i].getAsFile();
                loadImage(file);
                break;
            }
        }
    };

    React.useEffect(() => {
        document.addEventListener('paste', handlePaste);
        return () => {
            document.removeEventListener('paste', handlePaste);
        };
    }, []);

    React.useEffect(() => {
        if (image) drawImageOnCanvas(image);
    }, [boundingBoxes, image, selectedBoxIndex]);

    React.useEffect(() => {
        if (selectedBoxIndex !== null) {
            setLabelInput(boundingBoxes[selectedBoxIndex].label);
        } else {
            setLabelInput('');
        }
    }, [selectedBoxIndex, boundingBoxes]);

    React.useEffect(() => {
        saveClassesToStorage(classes);
    }, [classes]);

    const generateJSON = () => {
        return boundingBoxes.map(box => ({
            label: box.label,
            x1: box.x / image.width,
            x2: (box.x + box.width) / image.width,
            y1: box.y / image.height,
            y2: (box.y + box.height) / image.height
        }));
    };

    const copyToClipboard = () => {
        const data = generateJSON();
        navigator.clipboard.writeText(JSON.stringify(data, null, 2)).then(() => alert('Copied to clipboard!'));
    };

    const downloadFile = () => {
        const data = generateJSON();
        const blob = new Blob([JSON.stringify(data, null, 2)], {type: 'application/json'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'labels.json';
        a.click();
        URL.revokeObjectURL(url);
    };

    const pasteJSON = async () => {
        try {
            const text = await navigator.clipboard.readText();
            const data = JSON.parse(text);
            loadBoxes(data);
        } catch (e) {
            alert('Failed to paste JSON: ' + e.message);
        }
    };

    const loadBoxes = (data) => {
        if (!image) {
            alert('Please load an image first.');
            return;
        }
        const boxes = data.map(item => ({
            x: item.x1 * image.width,
            y: item.y1 * image.height,
            width: (item.x2 - item.x1) * image.width,
            height: (item.y2 - item.y1) * image.height,
            label: item.label
        }));
        setBoundingBoxes(boxes);
        setSelectedBoxIndex(null);
    };

    const loadJSONFile = (file) => {
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const data = JSON.parse(e.target.result);
                loadBoxes(data);
            } catch (e) {
                alert('Invalid JSON file: ' + e.message);
            }
        };
        reader.readAsText(file);
    };

    const addClass = () => {
        const name = prompt('Enter class name:');
        if (name && name.trim()) {
            setClasses([...classes, {id: nextClassId, name: name.trim()}]);
            setNextClassId(nextClassId + 1);
        }
    };

    const deleteClass = (id) => {
        if (classes.length <= 1) {
            alert('Must have at least one class');
            return;
        }
        if (!confirm('Are you sure you want to delete this class? All bounding boxes using this class will be reassigned to the first class.')) {
            return;
        }
        setClasses(classes.filter(c => c.id !== id));
        // Update bounding boxes that used this class
        setBoundingBoxes(boundingBoxes.map(box => {
            const classObj = classes.find(c => c.name === box.label);
            if (classObj && classObj.id === id) {
                return {...box, label: classes[0].name};
            }
            return box;
        }));
    };

    const exportClasses = () => {
        const data = JSON.stringify(classes, null, 2);
        const blob = new Blob([data], {type: 'application/json'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'classes.json';
        a.click();
        URL.revokeObjectURL(url);
    };

    const importClasses = (file) => {
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const data = JSON.parse(e.target.result);
                if (Array.isArray(data) && data.every(c => c.id !== undefined && c.name)) {
                    setClasses(data);
                    const maxId = Math.max(...data.map(c => c.id), 0);
                    setNextClassId(maxId + 1);
                } else {
                    alert('Invalid classes file format');
                }
            } catch (e) {
                alert('Failed to parse classes file: ' + e.message);
            }
        };
        reader.readAsText(file);
    };

    const renameClass = (id, newName) => {
        if (!newName || !newName.trim()) return;
        const trimmedName = newName.trim();
        if (classes.some(c => c.name === trimmedName && c.id !== id)) {
            alert('Class name already exists');
            return;
        }
        setClasses(classes.map(c => 
            c.id === id ? {...c, name: trimmedName} : c
        ));
        // Update bounding boxes with the new name
        setBoundingBoxes(boundingBoxes.map(box => 
            box.label === classes.find(c => c.id === id).name ? {...box, label: trimmedName} : box
        ));
    };

    const moveClass = (fromIndex, toIndex) => {
        const newClasses = [...classes];
        const [moved] = newClasses.splice(fromIndex, 1);
        newClasses.splice(toIndex, 0, moved);
        // Reassign IDs based on new order
        const reorderedClasses = newClasses.map((c, index) => ({...c, id: index}));
        setClasses(reorderedClasses);
        // Update nextClassId to be one more than the highest ID
        setNextClassId(reorderedClasses.length);
    };

    const startEditingClass = (id, currentName) => {
        setEditingClassId(id);
        setEditingClassName(currentName);
    };

    const saveEditingClass = () => {
        if (editingClassId !== null) {
            renameClass(editingClassId, editingClassName);
            setEditingClassId(null);
            setEditingClassName('');
        }
    };

    const cancelEditingClass = () => {
        setEditingClassId(null);
        setEditingClassName('');
    };

    const getClassId = (label) => {
        const classObj = classes.find(c => c.name === label);
        return classObj ? classObj.id : 0;
    };

    const generateYOLO = () => {
        return boundingBoxes.map(box => {
            const classId = getClassId(box.label);
            const x_center = (box.x + box.width / 2) / image.width;
            const y_center = (box.y + box.height / 2) / image.height;
            const width = box.width / image.width;
            const height = box.height / image.height;
            return `${classId} ${x_center.toFixed(6)} ${y_center.toFixed(6)} ${width.toFixed(6)} ${height.toFixed(6)}`;
        }).join('\n');
    };

    const generateCOCO = () => {
        const annotations = boundingBoxes.map((box, index) => ({
            id: index + 1,
            image_id: 1,
            category_id: getClassId(box.label) + 1, // COCO uses 1-based indexing
            bbox: [box.x, box.y, box.width, box.height],
            area: box.width * box.height,
            iscrowd: 0
        }));

        const categories = classes.map(c => ({
            id: c.id + 1,
            name: c.name,
            supercategory: 'object'
        }));

        return {
            images: [{
                id: 1,
                width: image.width,
                height: image.height,
                file_name: 'image.jpg' // Placeholder
            }],
            annotations: annotations,
            categories: categories
        };
    };

    const generateCSV = () => {
        // For classification, assume one dominant class per image
        const dominantClass = boundingBoxes.length > 0 ? boundingBoxes[0].label : classes[0].name;
        return `image_path,class\nimage.jpg,${dominantClass}`;
    };

    const downloadYOLO = () => {
        const data = generateYOLO();
        const blob = new Blob([data], {type: 'text/plain'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'labels.txt';
        a.click();
        URL.revokeObjectURL(url);
    };

    const downloadCOCO = () => {
        const data = generateCOCO();
        const blob = new Blob([JSON.stringify(data, null, 2)], {type: 'application/json'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'annotations.json';
        a.click();
        URL.revokeObjectURL(url);
    };

    const downloadCSV = () => {
        const data = generateCSV();
        const blob = new Blob([data], {type: 'text/csv'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'labels.csv';
        a.click();
        URL.revokeObjectURL(url);
    };

    return React.createElement('div', {className: 'container'}, 
        React.createElement('div', {className: 'image-panel', onDrop: handleDrop, onDragOver: handleDragOver}, 
            image ? React.createElement('canvas', {
                ref: canvasRef,
                width: '800',
                height: '600',
                style: {border: '1px solid #ddd', cursor: isAddingBox ? 'crosshair' : 'default'},
                onMouseDown: handleMouseDown,
                onMouseMove: handleMouseMove,
                onMouseUp: handleMouseUp
            }) : React.createElement('div', null,
                React.createElement('h2', null, 'Image Display Area - Drag and drop an image here or paste from clipboard'),
                React.createElement('input', {
                    type: 'file',
                    accept: 'image/*',
                    onChange: (e) => {
                        if (e.target.files.length > 0) {
                            loadImage(e.target.files[0]);
                        }
                    }
                })
            )
        ),
        React.createElement('div', {className: 'label-panel'},
            React.createElement('h2', {style: {cursor: 'pointer', userSelect: 'none'}, onClick: () => setClassesCollapsed(!classesCollapsed)}, 
                `Classes ${classesCollapsed ? '▶' : '▼'} (${classes.length})`
            ),
            !classesCollapsed ? React.createElement('div', null,
                React.createElement('button', {onClick: addClass}, 'Add Class'),
                React.createElement('button', {onClick: exportClasses}, 'Export Classes'),
                React.createElement('button', {onClick: () => {
                    const input = document.createElement('input');
                    input.type = 'file';
                    input.accept = '.json';
                    input.onchange = (e) => { if (e.target.files.length > 0) importClasses(e.target.files[0]); };
                    input.click();
                }}, 'Import Classes'),
                React.createElement('ul', {className: 'label-list'},
                    classes.map((c, index) =>
                        React.createElement('li', {
                            className: 'label-item',
                            key: c.id,
                            style: {display: 'flex', alignItems: 'center', justifyContent: 'space-between'}
                        }, 
                            editingClassId === c.id ? 
                                React.createElement('input', {
                                    type: 'text',
                                    value: editingClassName,
                                    onChange: (e) => setEditingClassName(e.target.value),
                                    onBlur: saveEditingClass,
                                    onKeyDown: (e) => {
                                        if (e.key === 'Enter') saveEditingClass();
                                        if (e.key === 'Escape') cancelEditingClass();
                                    },
                                    autoFocus: true,
                                    style: {flex: 1, marginRight: '5px'}
                                }) :
                                React.createElement('span', {
                                    onDoubleClick: () => startEditingClass(c.id, c.name),
                                    style: {flex: 1, cursor: 'pointer'}
                                }, `${c.id}: ${c.name}`),
                            React.createElement('div', null,
                                index > 0 ? React.createElement('button', {
                                    onClick: () => moveClass(index, index - 1),
                                    style: {marginRight: '2px', fontSize: '10px', padding: '2px 4px'}
                                }, '↑') : null,
                                index < classes.length - 1 ? React.createElement('button', {
                                    onClick: () => moveClass(index, index + 1),
                                    style: {marginRight: '2px', fontSize: '10px', padding: '2px 4px'}
                                }, '↓') : null,
                                React.createElement('button', {
                                    onClick: () => deleteClass(c.id),
                                    style: {fontSize: '10px', padding: '2px 4px', backgroundColor: '#ff6b6b', color: 'white', border: 'none', borderRadius: '2px'}
                                }, '×')
                            )
                        )
                    )
                )
            ) : null,
            React.createElement('h2', null, 'Labels'),
            React.createElement('button', {onClick: () => {
                if (isAddingBox) {
                    setIsAddingBox(false);
                } else {
                    setSelectedBoxIndex(null);
                    setIsAddingBox(true);
                }
            }}, isAddingBox ? 'Cancel Add' : 'Add Box'),
            selectedBoxIndex !== null ? React.createElement('div', null,
                React.createElement('select', {
                    value: labelInput,
                    onChange: (e) => {
                        setLabelInput(e.target.value);
                        const newBoxes = [...boundingBoxes];
                        newBoxes[selectedBoxIndex].label = e.target.value;
                        setBoundingBoxes(newBoxes);
                    }
                }, classes.map(c => React.createElement('option', {key: c.id, value: c.name}, c.name))),
                React.createElement('button', {
                    onClick: () => {
                        setBoundingBoxes(boundingBoxes.filter((_, i) => i !== selectedBoxIndex));
                        setSelectedBoxIndex(null);
                        setLabelInput('');
                    }
                }, 'Delete')
            ) : null,
            React.createElement('ul', {className: 'label-list'},
                boundingBoxes.map((box, index) =>
                    React.createElement('li', {
                        className: index === selectedBoxIndex ? 'label-item selected' : 'label-item',
                        key: index,
                        onClick: () => setSelectedBoxIndex(index)
                    }, box.label)
                )
            ),
            selectedBoxIndex !== null && image ? React.createElement('div', {style: {marginTop: '20px', fontSize: '12px', color: '#555'}}, (() => {
                const box = boundingBoxes[selectedBoxIndex];
                const x1 = (box.x / image.width).toFixed(3);
                const x2 = ((box.x + box.width) / image.width).toFixed(3);
                const y1 = (box.y / image.height).toFixed(3);
                const y2 = ((box.y + box.height) / image.height).toFixed(3);
                return `x1: ${x1}, x2: ${x2}, y1: ${y1}, y2: ${y2}`;
            })()) : null,
            image ? React.createElement('div', {style: {marginTop: '20px'}},
                React.createElement('button', {onClick: pasteJSON}, 'Paste JSON'),
                React.createElement('input', {
                    type: 'file',
                    accept: '.json',
                    style: {display: 'none'},
                    ref: jsonFileRef,
                    onChange: (e) => { if (e.target.files.length > 0) loadJSONFile(e.target.files[0]); }
                }),
                React.createElement('button', {onClick: () => jsonFileRef.current.click()}, 'Load JSON'),
                boundingBoxes.length > 0 ? React.createElement('div', {style: {marginTop: '10px'}},
                    React.createElement('button', {onClick: copyToClipboard}, 'Copy JSON'),
                    React.createElement('button', {onClick: downloadFile}, 'Download JSON'),
                    React.createElement('button', {onClick: downloadYOLO}, 'Download YOLO'),
                    React.createElement('button', {onClick: downloadCOCO}, 'Download COCO'),
                    React.createElement('button', {onClick: downloadCSV}, 'Download CSV')
                ) : null
            ) : null
        )
    );
};

ReactDOM.render(React.createElement(App), document.getElementById('root'));
    </script>
</body>
</html>
