<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Procedural Planet Generator</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background: radial-gradient(ellipse at center, #0a0a2e 0%, #000000 70%, #000000 100%);
        }
        canvas { display: block; }

        /* Space background */
        #space-background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: -1;
        }
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px;
            border-radius: 10px;
            font-family: Arial, sans-serif;
            font-size: 12px;
            z-index: 100;
            max-width: 200px;
        }
        #controls label { display: block; margin-bottom: 5px; }
        #controls input { width: 100%; margin-bottom: 10px; }
        #controls button {
            width: 100%;
            padding: 8px;
            background: #444;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        #controls button:hover { background: #666; }
    </style>
</head>
<body>
    <div id="space-background"></div>

    <div id="controls">
        <label>Noise Scale: <span id="noiseScaleValue">10</span></label>
        <input type="range" id="noiseScale" min="1" max="20" value="10" step="0.5">

        <label>Height Scale: <span id="heightScaleValue">1.0</span></label>
        <input type="range" id="heightScale" min="0" max="2" value="1.0" step="0.1">

        <label>Planet Size: <span id="planetSizeValue">5</span></label>
        <input type="range" id="planetSize" min="1" max="10" value="5" step="0.5">

        <label>Rotation Speed: <span id="rotationSpeedValue">0.005</span></label>
        <input type="range" id="rotationSpeed" min="0" max="0.02" value="0.005" step="0.001">

        <label>Water Level: <span id="waterLevelValue">0.3</span></label>
        <input type="range" id="waterLevel" min="0" max="1" value="0.3" step="0.05">

        <label>Mountain Level: <span id="mountainLevelValue">0.6</span></label>
        <input type="range" id="mountainLevel" min="0" max="1" value="0.6" step="0.05">

        <button id="newSeed">New Seed</button>
        <button id="resetAnimals">Reset Animals</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script>
        // Simple Perlin noise implementation
        class PerlinNoise {
            constructor(seed = null) {
                this.permutation = [];
                const random = seed ? this.seededRandom(seed) : Math.random;
                for (let i = 0; i < 256; i++) {
                    this.permutation[i] = Math.floor(random() * 256);
                }
                this.p = [...this.permutation, ...this.permutation];
            }

            seededRandom(seed) {
                return function() {
                    seed = (seed * 9301 + 49297) % 233280;
                    return seed / 233280;
                };
            }

            fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
            lerp(t, a, b) { return a + t * (b - a); }
            grad(hash, x, y, z) {
                const h = hash & 15;
                const u = h < 8 ? x : y;
                const v = h < 4 ? y : h == 12 || h == 14 ? x : z;
                return ((h & 1) == 0 ? u : -u) + ((h & 2) == 0 ? v : -v);
            }

            noise(x, y, z) {
                const X = Math.floor(x) & 255;
                const Y = Math.floor(y) & 255;
                const Z = Math.floor(z) & 255;
                x -= Math.floor(x);
                y -= Math.floor(y);
                z -= Math.floor(z);
                const u = this.fade(x);
                const v = this.fade(y);
                const w = this.fade(z);
                const A = this.p[X] + Y, AA = this.p[A] + Z, AB = this.p[A + 1] + Z;
                const B = this.p[X + 1] + Y, BA = this.p[B] + Z, BB = this.p[B + 1] + Z;
                return this.lerp(w, this.lerp(v, this.lerp(u, this.grad(this.p[AA], x, y, z),
                                                     this.grad(this.p[BA], x - 1, y, z)),
                                         this.lerp(u, this.grad(this.p[AB], x, y - 1, z),
                                                     this.grad(this.p[BB], x - 1, y - 1, z))),
                             this.lerp(v, this.lerp(u, this.grad(this.p[AA + 1], x, y, z - 1),
                                                     this.grad(this.p[BA + 1], x - 1, y, z - 1)),
                                         this.lerp(u, this.grad(this.p[AB + 1], x, y - 1, z - 1),
                                                     this.grad(this.p[BB + 1], x - 1, y - 1, z - 1))));
            }
        }

        // Animal class
        class Animal {
            constructor(position, planetSize) {
                this.planetSize = planetSize;
                this.theta = position.theta || Math.random() * Math.PI * 2; // azimuthal angle
                this.phi = position.phi || Math.acos(2 * Math.random() - 1); // polar angle
                this.cachedTerrainHeight = null; // Cache terrain height to prevent bobbing
                this.mesh = this.createMesh();
                this.targetTheta = this.theta;
                this.targetPhi = this.phi;
                this.hunger = 0;
                this.isPrey = true; // Mark as prey for predators
                scene.add(this.mesh);
                this.updatePosition();
            }

            createMesh() {
                const geometry = new THREE.SphereGeometry(ANIMAL_SIZE, 8, 8);
                const material = new THREE.MeshPhongMaterial({ color: 0xff0000 });
                return new THREE.Mesh(geometry, material);
            }

            updatePosition() {
                // Sample terrain height at this position
                const terrainHeight = this.sampleTerrainHeight();

                // Position on surface with terrain displacement
                const surfaceRadius = this.planetSize + terrainHeight;
                const x = surfaceRadius * Math.sin(this.phi) * Math.cos(this.theta);
                const y = surfaceRadius * Math.cos(this.phi);
                const z = surfaceRadius * Math.sin(this.phi) * Math.sin(this.theta);

                // Apply planet rotation to keep animals on surface as planet rotates
                if (planet) {
                    const rotationMatrix = new THREE.Matrix4();
                    rotationMatrix.makeRotationY(planet.rotation.y);
                    const rotatedPosition = new THREE.Vector3(x, y, z).applyMatrix4(rotationMatrix);
                    this.mesh.position.copy(rotatedPosition);

                    // Orient the animal to face outward from planet center (accounting for rotation)
                    const rotatedOutward = new THREE.Vector3(x * 2, y * 2, z * 2).applyMatrix4(rotationMatrix);
                    this.mesh.lookAt(rotatedOutward);
                } else {
                    this.mesh.position.set(x, y, z);
                    this.mesh.lookAt(x * 2, y * 2, z * 2);
                }
            }

            sampleTerrainHeight() {
                // Use cached terrain height if available to prevent bobbing
                if (this.cachedTerrainHeight !== null) {
                    return this.cachedTerrainHeight;
                }

                // Use the same Perlin noise calculation as the planet generation
                const perlin = new PerlinNoise(currentSeed);

                // Normalize direction vector
                const nx = Math.sin(this.phi) * Math.cos(this.theta);
                const ny = Math.cos(this.phi);
                const nz = Math.sin(this.phi) * Math.sin(this.theta);

                // Generate noise for height displacement (same as planet generation)
                const noise1 = perlin.noise(nx * 4, ny * 4, nz * 4);
                const noise2 = perlin.noise(nx * 8, ny * 8, nz * 8) * 0.5;
                const noise3 = perlin.noise(nx * 16, ny * 16, nz * 16) * 0.25;
                const totalNoise = (noise1 + noise2 + noise3) * 0.5 + 0.5; // Normalize to 0-1

                // Return displacement (same formula as planet generation)
                const displacement = (totalNoise - 0.5) * currentHeightScale;

                // Ensure minimum surface radius to prevent animals from going below surface
                const minRadius = currentPlanetSize - currentHeightScale * 0.3; // Allow some depth but not too much
                const surfaceRadius = currentPlanetSize + displacement;

                // Cache the result to prevent bobbing
                this.cachedTerrainHeight = Math.max(surfaceRadius - currentPlanetSize, minRadius - currentPlanetSize);
                return this.cachedTerrainHeight;
            }

            move() {
                // Random movement
                if (Math.random() < 0.05) { // 5% chance to change direction each frame
                    this.targetTheta = this.theta + (Math.random() - 0.5) * 0.5;
                    this.targetPhi = Math.max(0.1, Math.min(Math.PI - 0.1,
                        this.phi + (Math.random() - 0.5) * 0.5));
                }

                // Move towards target
                const dTheta = this.targetTheta - this.theta;
                const dPhi = this.targetPhi - this.phi;

                this.theta += Math.sign(dTheta) * Math.min(Math.abs(dTheta), ANIMAL_SPEED);
                this.phi += Math.sign(dPhi) * Math.min(Math.abs(dPhi), ANIMAL_SPEED);

                this.updatePosition();
                this.hunger += 0.001; // Increase hunger over time
            }

            eat() {
                this.hunger = 0;
            }

            remove() {
                scene.remove(this.mesh);
                this.mesh.geometry.dispose();
                this.mesh.material.dispose();
            }
        }

        // Predator class - hunts animals instead of plants
        class Predator {
            constructor(position, planetSize) {
                this.planetSize = planetSize;
                this.theta = position.theta || Math.random() * Math.PI * 2; // azimuthal angle
                this.phi = position.phi || Math.acos(2 * Math.random() - 1); // polar angle
                this.cachedTerrainHeight = null; // Cache terrain height to prevent bobbing
                this.mesh = this.createMesh();
                this.targetTheta = this.theta;
                this.targetPhi = this.phi;
                this.hunger = 0;
                this.isPredator = true; // Mark as predator
                scene.add(this.mesh);
                this.updatePosition();
            }

            createMesh() {
                const geometry = new THREE.SphereGeometry(PREDATOR_SIZE, 8, 8);
                const material = new THREE.MeshPhongMaterial({ color: 0x9932CC }); // Purple color
                return new THREE.Mesh(geometry, material);
            }

            updatePosition() {
                // Sample terrain height at this position
                const terrainHeight = this.sampleTerrainHeight();

                // Position on surface with terrain displacement
                const surfaceRadius = this.planetSize + terrainHeight;
                const x = surfaceRadius * Math.sin(this.phi) * Math.cos(this.theta);
                const y = surfaceRadius * Math.cos(this.phi);
                const z = surfaceRadius * Math.sin(this.phi) * Math.sin(this.theta);

                // Apply planet rotation to keep predators on surface as planet rotates
                if (planet) {
                    const rotationMatrix = new THREE.Matrix4();
                    rotationMatrix.makeRotationY(planet.rotation.y);
                    const rotatedPosition = new THREE.Vector3(x, y, z).applyMatrix4(rotationMatrix);
                    this.mesh.position.copy(rotatedPosition);

                    // Orient the predator to face outward from planet center (accounting for rotation)
                    const rotatedOutward = new THREE.Vector3(x * 2, y * 2, z * 2).applyMatrix4(rotationMatrix);
                    this.mesh.lookAt(rotatedOutward);
                } else {
                    this.mesh.position.set(x, y, z);
                    this.mesh.lookAt(x * 2, y * 2, z * 2);
                }
            }

            sampleTerrainHeight() {
                // Use cached terrain height if available to prevent bobbing
                if (this.cachedTerrainHeight !== null) {
                    return this.cachedTerrainHeight;
                }

                // Use the same Perlin noise calculation as the planet generation
                const perlin = new PerlinNoise(currentSeed);

                // Normalize direction vector
                const nx = Math.sin(this.phi) * Math.cos(this.theta);
                const ny = Math.cos(this.phi);
                const nz = Math.sin(this.phi) * Math.sin(this.theta);

                // Generate noise for height displacement (same as planet generation)
                const noise1 = perlin.noise(nx * 4, ny * 4, nz * 4);
                const noise2 = perlin.noise(nx * 8, ny * 8, nz * 8) * 0.5;
                const noise3 = perlin.noise(nx * 16, ny * 16, nz * 16) * 0.25;
                const totalNoise = (noise1 + noise2 + noise3) * 0.5 + 0.5; // Normalize to 0-1

                // Return displacement (same formula as planet generation)
                const displacement = (totalNoise - 0.5) * currentHeightScale;

                // Ensure minimum surface radius to prevent predators from going below surface
                const minRadius = currentPlanetSize - currentHeightScale * 0.3;
                const surfaceRadius = currentPlanetSize + displacement;

                // Cache the result to prevent bobbing
                this.cachedTerrainHeight = Math.max(surfaceRadius - currentPlanetSize, minRadius - currentPlanetSize);
                return this.cachedTerrainHeight;
            }

            move() {
                // Random movement
                if (Math.random() < 0.03) { // Less frequent direction changes for predators
                    this.targetTheta = this.theta + (Math.random() - 0.5) * 0.8;
                    this.targetPhi = Math.max(0.1, Math.min(Math.PI - 0.1,
                        this.phi + (Math.random() - 0.5) * 0.8));
                }

                // Move towards target
                const dTheta = this.targetTheta - this.theta;
                const dPhi = this.targetPhi - this.phi;

                this.theta += Math.sign(dTheta) * Math.min(Math.abs(dTheta), PREDATOR_SPEED);
                this.phi += Math.sign(dPhi) * Math.min(Math.abs(dPhi), PREDATOR_SPEED);

                this.updatePosition();
                this.hunger += 0.0005; // Slower hunger increase for predators
            }

            eat() {
                this.hunger = 0;
            }

            remove() {
                scene.remove(this.mesh);
                this.mesh.geometry.dispose();
                this.mesh.material.dispose();
            }
        }

        // Plant class with growth and reproduction
        class Plant {
            constructor(position, planetSize) {
                this.planetSize = planetSize;
                this.theta = position.theta || Math.random() * Math.PI * 2;
                this.phi = position.phi || Math.acos(2 * Math.random() - 1);
                this.age = 0; // Plant age/growth stage
                this.energy = 0.5; // Plant energy for reproduction
                this.cachedTerrainHeight = null; // Cache terrain height to prevent bobbing
                this.mesh = this.createMesh();
                scene.add(this.mesh);
                this.updatePosition();
            }

            createMesh() {
                const size = PLANT_SIZE * (0.5 + this.age * 0.5); // Grow with age
                const geometry = new THREE.SphereGeometry(size, 6, 6);
                const material = new THREE.MeshPhongMaterial({
                    color: this.age > 0.8 ? 0x90EE90 : 0x00ff00 // Mature plants are lighter green
                });
                return new THREE.Mesh(geometry, material);
            }

            updatePosition() {
                // Sample terrain height at this position
                const terrainHeight = this.sampleTerrainHeight();

                // Position on surface with terrain displacement
                const surfaceRadius = this.planetSize + terrainHeight;
                const x = surfaceRadius * Math.sin(this.phi) * Math.cos(this.theta);
                const y = surfaceRadius * Math.cos(this.phi);
                const z = surfaceRadius * Math.sin(this.phi) * Math.sin(this.theta);

                // Apply planet rotation to keep plants on surface as planet rotates
                if (planet) {
                    const rotationMatrix = new THREE.Matrix4();
                    rotationMatrix.makeRotationY(planet.rotation.y);
                    const rotatedPosition = new THREE.Vector3(x, y, z).applyMatrix4(rotationMatrix);
                    this.mesh.position.copy(rotatedPosition);
                } else {
                    this.mesh.position.set(x, y, z);
                }
            }

            sampleTerrainHeight() {
                // Use cached terrain height if available to prevent bobbing
                if (this.cachedTerrainHeight !== null) {
                    return this.cachedTerrainHeight;
                }

                // Use the same Perlin noise calculation as the planet generation
                const perlin = new PerlinNoise(currentSeed);

                // Normalize direction vector
                const nx = Math.sin(this.phi) * Math.cos(this.theta);
                const ny = Math.cos(this.phi);
                const nz = Math.sin(this.phi) * Math.sin(this.theta);

                // Generate noise for height displacement (same as planet generation)
                const noise1 = perlin.noise(nx * 4, ny * 4, nz * 4);
                const noise2 = perlin.noise(nx * 8, ny * 8, nz * 8) * 0.5;
                const noise3 = perlin.noise(nx * 16, ny * 16, nz * 16) * 0.25;
                const totalNoise = (noise1 + noise2 + noise3) * 0.5 + 0.5; // Normalize to 0-1

                // Return displacement (same formula as planet generation)
                const displacement = (totalNoise - 0.5) * currentHeightScale;

                // Ensure minimum surface radius to prevent plants from going below surface
                const minRadius = currentPlanetSize - currentHeightScale * 0.3;
                const surfaceRadius = currentPlanetSize + displacement;

                // Cache the result to prevent bobbing
                this.cachedTerrainHeight = Math.max(surfaceRadius - currentPlanetSize, minRadius - currentPlanetSize);
                return this.cachedTerrainHeight;
            }

            grow() {
                // Grow over time
                this.age = Math.min(1.0, this.age + PLANT_GROWTH_RATE);
                this.energy += PLANT_GROWTH_RATE * 0.5;

                // Update visual size and color when mature
                if (this.age > 0.8 && this.energy > 1.0) {
                    // Mature plant - update mesh
                    scene.remove(this.mesh);
                    this.mesh.geometry.dispose();
                    this.mesh.material.dispose();
                    this.mesh = this.createMesh();
                    scene.add(this.mesh);
                    this.updatePosition();
                }
            }

            canReproduce() {
                return this.age > 0.8 && this.energy > 1.2 && plants.length < MAX_PLANTS;
            }

            reproduce() {
                if (this.canReproduce()) {
                    // Create offspring nearby
                    const offspringPosition = {
                        theta: this.theta + (Math.random() - 0.5) * 0.3,
                        phi: Math.max(0.1, Math.min(Math.PI - 0.1, this.phi + (Math.random() - 0.5) * 0.3))
                    };

                    const offspring = new Plant(offspringPosition, this.planetSize);
                    plants.push(offspring);

                    // Reduce energy after reproduction
                    this.energy -= 0.8;
                }
            }

            remove() {
                scene.remove(this.mesh);
                this.mesh.geometry.dispose();
                this.mesh.material.dispose();
            }
        }

        // Utility functions
        function getDistanceOnSphere(a, b) {
            const dTheta = Math.abs(a.theta - b.theta);
            const dPhi = Math.abs(a.phi - b.phi);
            return Math.sqrt(dTheta * dTheta + dPhi * dPhi);
        }

        function spawnPlants() {
            if (Math.random() < PLANT_SPAWN_RATE && plants.length < MAX_PLANTS) {
                const position = {
                    theta: Math.random() * Math.PI * 2,
                    phi: Math.acos(2 * Math.random() - 1)
                };
                plants.push(new Plant(position, currentPlanetSize));
            }
        }

        function updatePlants() {
            for (let i = plants.length - 1; i >= 0; i--) {
                const plant = plants[i];
                plant.grow();

                // Chance for reproduction
                if (Math.random() < PLANT_REPRODUCTION_CHANCE) {
                    plant.reproduce();
                }
            }
        }

        function findNearestPlant(animal) {
            let nearestPlant = null;
            let minDistance = Infinity;

            for (const plant of plants) {
                const distance = getDistanceOnSphere(animal, plant);
                if (distance < minDistance) {
                    minDistance = distance;
                    nearestPlant = plant;
                }
            }

            return nearestPlant;
        }

        function findNearestPrey(predator) {
            let nearestPrey = null;
            let minDistance = Infinity;

            for (const animal of animals) {
                const distance = getDistanceOnSphere(predator, animal);
                if (distance < minDistance) {
                    minDistance = distance;
                    nearestPrey = animal;
                }
            }

            return nearestPrey;
        }

        function updatePredators() {
            for (let i = predators.length - 1; i >= 0; i--) {
                const predator = predators[i];

                // If hungry, seek nearest prey
                if (predator.hunger > 0.2 && animals.length > 0) {
                    const nearestPrey = findNearestPrey(predator);
                    if (nearestPrey) {
                        // Move towards the prey
                        const dTheta = nearestPrey.theta - predator.theta;
                        const dPhi = nearestPrey.phi - predator.phi;

                        // Normalize angles for shortest path
                        let targetTheta = predator.theta + dTheta;
                        let targetPhi = Math.max(0.1, Math.min(Math.PI - 0.1, predator.phi + dPhi));

                        // Handle theta wraparound
                        if (Math.abs(dTheta) > Math.PI) {
                            targetTheta = predator.theta - Math.sign(dTheta) * (2 * Math.PI - Math.abs(dTheta));
                        }

                        predator.targetTheta = targetTheta;
                        predator.targetPhi = targetPhi;
                    }
                } else {
                    // Random movement when not hungry
                    if (Math.random() < 0.03) { // Less frequent direction changes for predators
                        predator.targetTheta = predator.theta + (Math.random() - 0.5) * 0.8;
                        predator.targetPhi = Math.max(0.1, Math.min(Math.PI - 0.1,
                            predator.phi + (Math.random() - 0.5) * 0.8));
                    }
                }

                predator.move();

                // Remove predators that are too hungry
                if (predator.hunger > 1.0) {
                    predator.remove();
                    predators.splice(i, 1);
                }
            }
        }

        function checkPredatorCollisions() {
            for (let i = predators.length - 1; i >= 0; i--) {
                const predator = predators[i];
                for (let j = animals.length - 1; j >= 0; j--) {
                    const animal = animals[j];
                    const distance = getDistanceOnSphere(predator, animal);

                    if (distance < 0.12) { // Collision threshold (slightly larger for predators)
                        // Predator eats animal
                        predator.eat();
                        animal.remove();
                        animals.splice(j, 1);

                        // Predator population growth - spawn new predator occasionally
                        if (predators.length < MAX_PREDATORS && Math.random() < 0.3) {
                            const newPredator = new Predator({
                                theta: predator.theta + (Math.random() - 0.5) * 0.3,
                                phi: predator.phi + (Math.random() - 0.5) * 0.3
                            }, currentPlanetSize);
                            predators.push(newPredator);
                        }
                        break;
                    }
                }
            }
        }

        function checkCollisions() {
            for (let i = animals.length - 1; i >= 0; i--) {
                const animal = animals[i];
                for (let j = plants.length - 1; j >= 0; j--) {
                    const plant = plants[j];
                    const distance = getDistanceOnSphere(animal, plant);

                    if (distance < 0.1) { // Collision threshold
                        // Animal eats plant
                        animal.eat();
                        plant.remove();
                        plants.splice(j, 1);

                        // Population growth - double the animal
                        if (animals.length < MAX_POPULATION) {
                            const newAnimal = new Animal({
                                theta: animal.theta + (Math.random() - 0.5) * 0.2,
                                phi: animal.phi + (Math.random() - 0.5) * 0.2
                            }, currentPlanetSize);
                            animals.push(newAnimal);
                        }
                        break;
                    }
                }
            }
        }

        function updateAnimals() {
            for (let i = animals.length - 1; i >= 0; i--) {
                const animal = animals[i];

                // Smarter AI: If hungry, seek nearest plant
                if (animal.hunger > 0.3 && plants.length > 0) {
                    const nearestPlant = findNearestPlant(animal);
                    if (nearestPlant) {
                        // Move towards the plant
                        const dTheta = nearestPlant.theta - animal.theta;
                        const dPhi = nearestPlant.phi - animal.phi;

                        // Normalize angles for shortest path
                        let targetTheta = animal.theta + dTheta;
                        let targetPhi = Math.max(0.1, Math.min(Math.PI - 0.1, animal.phi + dPhi));

                        // Handle theta wraparound
                        if (Math.abs(dTheta) > Math.PI) {
                            targetTheta = animal.theta - Math.sign(dTheta) * (2 * Math.PI - Math.abs(dTheta));
                        }

                        animal.targetTheta = targetTheta;
                        animal.targetPhi = targetPhi;
                    }
                } else {
                    // Random movement when not hungry
                    if (Math.random() < 0.05) { // 5% chance to change direction each frame
                        animal.targetTheta = animal.theta + (Math.random() - 0.5) * 0.5;
                        animal.targetPhi = Math.max(0.1, Math.min(Math.PI - 0.1,
                            animal.phi + (Math.random() - 0.5) * 0.5));
                    }
                }

                animal.move();

                // Remove animals that are too hungry
                if (animal.hunger > 1.0) {
                    animal.remove();
                    animals.splice(i, 1);
                }
            }
        }

        function resetAnimals() {
            // Remove all existing animals
            animals.forEach(animal => animal.remove());
            animals = [];

            // Remove all existing predators
            predators.forEach(predator => predator.remove());
            predators = [];

            // Remove all existing plants
            plants.forEach(plant => plant.remove());
            plants = [];

            // Spawn initial animals
            for (let i = 0; i < 2; i++) {
                const position = {
                    theta: Math.random() * Math.PI * 2,
                    phi: Math.acos(2 * Math.random() - 1)
                };
                animals.push(new Animal(position, currentPlanetSize));
            }

            // Spawn initial predator
            const predatorPosition = {
                theta: Math.random() * Math.PI * 2,
                phi: Math.acos(2 * Math.random() - 1)
            };
            predators.push(new Predator(predatorPosition, currentPlanetSize));
        }

        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        let planet;
        let sun;
        let otherPlanets = [];
        let currentSeed = null;
        let currentNoiseScale = 10;
        let currentHeightScale = 1.0;
        let currentPlanetSize = 5;
        let currentRotationSpeed = 0.005;
        let currentWaterLevel = 0.3;
        let currentMountainLevel = 0.6;

        // Animal simulation variables
        let animals = [];
        let predators = [];
        let plants = [];
        const MAX_POPULATION = 50;
        const MAX_PREDATORS = 10;
        const PLANT_SPAWN_RATE = 0.05; // Increased spawn rate
        const MAX_PLANTS = 40; // More plants
        const ANIMAL_SPEED = 0.015; // Slightly faster
        const PREDATOR_SPEED = 0.02; // Faster than animals
        const PLANT_SIZE = 0.08;
        const ANIMAL_SIZE = 0.15;
        const PREDATOR_SIZE = 0.2; // Larger than animals
        const PLANT_GROWTH_RATE = 0.002;
        const PLANT_REPRODUCTION_CHANCE = 0.001;

        function generatePlanet(seed = null, noiseScale = 10, heightScale = 1.0, planetSize = 5, waterLevel = 0.3, mountainLevel = 0.6) {
            // Remove existing planet
            if (planet) {
                scene.remove(planet);
                planet.geometry.dispose();
                planet.material.dispose();
            }

            const perlin = new PerlinNoise(seed);

            // Generate texture with higher resolution and more complex patterns
            const size = 1024;
            const data = new Uint8Array(size * size * 4);

            for (let i = 0; i < size; i++) {
                for (let j = 0; j < size; j++) {
                    const x = i / size * noiseScale;
                    const y = j / size * noiseScale;

                    // Generate multiple octaves of noise for more detail
                    const noise1 = perlin.noise(x, y, 0);
                    const noise2 = perlin.noise(x * 2, y * 2, 0) * 0.5;
                    const noise3 = perlin.noise(x * 4, y * 4, 0) * 0.25;
                    const noise4 = perlin.noise(x * 8, y * 8, 0) * 0.125;
                    const noise5 = perlin.noise(x * 16, y * 16, 0) * 0.0625;

                    const totalNoise = (noise1 + noise2 + noise3 + noise4 + noise5) * 0.5 + 0.5;
                    const noise = Math.max(0, Math.min(1, totalNoise)); // Clamp to 0-1

                    // Add some turbulence for more organic patterns
                    const turbulence = perlin.noise(x * 3 + noise, y * 3 + noise, 0) * 0.1;
                    const finalNoise = Math.max(0, Math.min(1, noise + turbulence));

                    // Temperature gradient (poles are colder)
                    const latitude = Math.abs((j / size - 0.5) * 2); // 0 at equator, 1 at poles
                    const temperature = 1 - latitude * 0.7; // Warmer at equator

                    // Humidity variation
                    const humidity = perlin.noise(x * 0.5, y * 0.5, 100) * 0.5 + 0.5;

                    let r, g, b;
                    if (finalNoise < waterLevel) {
                        // Water biomes
                        if (temperature < 0.3) {
                            // Ice caps
                            r = 200; g = 220; b = 255;
                        } else if (humidity > 0.7) {
                            // Deep ocean
                            r = 0; g = 20; b = 80;
                        } else {
                            // Regular ocean
                            r = 0; g = 100; b = 200;
                        }
                    } else if (finalNoise < mountainLevel) {
                        // Land biomes
                        if (temperature < 0.4) {
                            // Tundra
                            r = 160; g = 140; b = 120;
                        } else if (temperature > 0.8 && humidity > 0.6) {
                            // Tropical rainforest
                            r = 20; g = 80; b = 30;
                        } else if (temperature > 0.7 && humidity < 0.4) {
                            // Desert
                            r = 194; g = 178; b = 128;
                        } else if (humidity > 0.7) {
                            // Forest
                            r = 34; g = 139; b = 34;
                        } else if (humidity > 0.5) {
                            // Grassland
                            r = 124; g = 252; b = 0;
                        } else {
                            // Plains
                            r = 154; g = 205; b = 50;
                        }
                    } else {
                        // Mountain biomes
                        if (temperature < 0.3) {
                            // Snow-capped mountains
                            r = 255; g = 250; b = 250;
                        } else if (temperature > 0.8) {
                            // Volcanic mountains
                            r = 80; g = 40; b = 20;
                        } else {
                            // Regular mountains
                            r = 139; g = 69; b = 19;
                        }
                    }

                    // Add some color variation for more realism
                    const variation = (perlin.noise(x * 20, y * 20, 200) - 0.5) * 0.1;
                    r = Math.max(0, Math.min(255, r + variation * 255));
                    g = Math.max(0, Math.min(255, g + variation * 255));
                    b = Math.max(0, Math.min(255, b + variation * 255));

                    const idx = (i * size + j) * 4;
                    data[idx] = r;
                    data[idx + 1] = g;
                    data[idx + 2] = b;
                    data[idx + 3] = 255;
                }
            }

            const texture = new THREE.DataTexture(data, size, size, THREE.RGBAFormat);
            texture.needsUpdate = true;

            // Create planet
            const geometry = new THREE.SphereGeometry(planetSize, 64, 64);
            const material = new THREE.MeshPhongMaterial({ map: texture });

            // Apply height displacement using Perlin noise
            const positions = geometry.attributes.position.array;

            for (let i = 0; i < positions.length; i += 3) {
                const x = positions[i];
                const y = positions[i + 1];
                const z = positions[i + 2];

                // Normalize to get direction
                const length = Math.sqrt(x * x + y * y + z * z);
                const nx = x / length;
                const ny = y / length;
                const nz = z / length;

                // Generate noise for height displacement
                const noise1 = perlin.noise(nx * 4, ny * 4, nz * 4);
                const noise2 = perlin.noise(nx * 8, ny * 8, nz * 8) * 0.5;
                const noise3 = perlin.noise(nx * 16, ny * 16, nz * 16) * 0.25;
                const totalNoise = (noise1 + noise2 + noise3) * 0.5 + 0.5; // Normalize to 0-1

                // Displace vertex along normal
                const displacement = (totalNoise - 0.5) * heightScale;
                positions[i] = x + nx * displacement;
                positions[i + 1] = y + ny * displacement;
                positions[i + 2] = z + nz * displacement;
            }

            geometry.attributes.position.needsUpdate = true;
            geometry.computeVertexNormals(); // Recalculate normals for proper lighting

            planet = new THREE.Mesh(geometry, material);
            scene.add(planet);
        }

        // Generate initial planet
        generatePlanet();

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(10, 10, 5);
        scene.add(directionalLight);

        // Camera position
        camera.position.z = 15;

        // Controls
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            if (planet) planet.rotation.y += currentRotationSpeed;

            // Animate sun and planets
            if (sun) {
                sun.rotation.y += 0.01; // Sun rotation
            }

            // Orbit other planets
            otherPlanets.forEach((planetData, index) => {
                const time = Date.now() * 0.001; // Convert to seconds
                const angle = time * planetData.speed + (index * Math.PI * 2 / otherPlanets.length); // Offset each planet

                // Calculate orbital position
                const x = Math.cos(angle) * planetData.distance;
                const z = Math.sin(angle) * planetData.distance;
                const y = planetData.mesh.position.y; // Keep original Y position

                planetData.mesh.position.set(x, y, z);
                planetData.mesh.rotation.y += 0.02; // Planet rotation
            });

            // Update plant positions to follow planet rotation
            plants.forEach(plant => plant.updatePosition());
            animals.forEach(animal => animal.updatePosition());
            predators.forEach(predator => predator.updatePosition());

            // Update plant simulation
            spawnPlants();
            updatePlants();

            // Update animal simulation
            updateAnimals();
            checkCollisions();

            // Update predator simulation
            updatePredators();
            checkPredatorCollisions();

            renderer.render(scene, camera);
        }
        animate();

        // Function to update all entities when planet changes
        function updateAllEntityPositions() {
            // Clear cached terrain heights so entities recalculate positions
            plants.forEach(plant => plant.cachedTerrainHeight = null);
            animals.forEach(animal => animal.cachedTerrainHeight = null);
            predators.forEach(predator => predator.cachedTerrainHeight = null);

            // Update all plants
            plants.forEach(plant => {
                plant.planetSize = currentPlanetSize;
                plant.updatePosition();
            });

            // Update all animals
            animals.forEach(animal => {
                animal.planetSize = currentPlanetSize;
                animal.updatePosition();
            });

            // Update all predators
            predators.forEach(predator => {
                predator.planetSize = currentPlanetSize;
                predator.updatePosition();
            });
        }

        // Control event listeners
        document.getElementById('noiseScale').addEventListener('input', (e) => {
            currentNoiseScale = parseFloat(e.target.value);
            document.getElementById('noiseScaleValue').textContent = currentNoiseScale;
            generatePlanet(currentSeed, currentNoiseScale, currentHeightScale, currentPlanetSize, currentWaterLevel, currentMountainLevel);
            updateAllEntityPositions();
        });

        document.getElementById('heightScale').addEventListener('input', (e) => {
            currentHeightScale = parseFloat(e.target.value);
            document.getElementById('heightScaleValue').textContent = currentHeightScale;
            generatePlanet(currentSeed, currentNoiseScale, currentHeightScale, currentPlanetSize, currentWaterLevel, currentMountainLevel);
            updateAllEntityPositions();
        });

        document.getElementById('planetSize').addEventListener('input', (e) => {
            currentPlanetSize = parseFloat(e.target.value);
            document.getElementById('planetSizeValue').textContent = currentPlanetSize;
            generatePlanet(currentSeed, currentNoiseScale, currentHeightScale, currentPlanetSize, currentWaterLevel, currentMountainLevel);
            updateAllEntityPositions();
        });

        document.getElementById('rotationSpeed').addEventListener('input', (e) => {
            currentRotationSpeed = parseFloat(e.target.value);
            document.getElementById('rotationSpeedValue').textContent = currentRotationSpeed;
        });

        document.getElementById('waterLevel').addEventListener('input', (e) => {
            currentWaterLevel = parseFloat(e.target.value);
            document.getElementById('waterLevelValue').textContent = currentWaterLevel;
            generatePlanet(currentSeed, currentNoiseScale, currentHeightScale, currentPlanetSize, currentWaterLevel, currentMountainLevel);
            updateAllEntityPositions();
        });

        document.getElementById('mountainLevel').addEventListener('input', (e) => {
            currentMountainLevel = parseFloat(e.target.value);
            document.getElementById('mountainLevelValue').textContent = currentMountainLevel;
            generatePlanet(currentSeed, currentNoiseScale, currentHeightScale, currentPlanetSize, currentWaterLevel, currentMountainLevel);
            updateAllEntityPositions();
        });

        document.getElementById('newSeed').addEventListener('click', () => {
            currentSeed = Math.floor(Math.random() * 1000000);
            generatePlanet(currentSeed, currentNoiseScale, currentHeightScale, currentPlanetSize, currentWaterLevel, currentMountainLevel);
            updateAllEntityPositions();
        });

        document.getElementById('resetAnimals').addEventListener('click', () => {
            resetAnimals();
        });

        // Initialize animals
        resetAnimals();

        // Create starfield in 3D space with galaxy
        function createStarfield() {
            const starGeometry = new THREE.BufferGeometry();
            const starCount = 2000;
            const positions = new Float32Array(starCount * 3);
            const colors = new Float32Array(starCount * 3);

            for (let i = 0; i < starCount; i++) {
                let x, y, z, radius;

                // Create galaxy-like distribution with spiral arms
                if (i < 1500) {
                    // Main galaxy disk
                    const angle = Math.random() * Math.PI * 4; // Two full rotations
                    const distance = Math.random() * 80 + 20; // Distance from center
                    const height = (Math.random() - 0.5) * 10; // Thin disk

                    // Spiral arm effect
                    const armOffset = Math.sin(angle * 2) * 5;
                    x = (distance + armOffset) * Math.cos(angle);
                    y = height;
                    z = (distance + armOffset) * Math.sin(angle);
                    radius = Math.sqrt(x*x + y*y + z*z);
                } else {
                    // Background stars
                    radius = 100 + Math.random() * 200;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    x = radius * Math.sin(phi) * Math.cos(theta);
                    y = radius * Math.cos(phi);
                    z = radius * Math.sin(phi) * Math.sin(theta);
                }

                positions[i * 3] = x;
                positions[i * 3 + 1] = y;
                positions[i * 3 + 2] = z;

                // Color variation based on distance and position
                const distanceFromCenter = Math.sqrt(x*x + y*y + z*z);
                if (distanceFromCenter < 50) {
                    // Core stars - more yellow/white
                    const brightness = 0.9 + Math.random() * 0.1;
                    colors[i * 3] = brightness;     // R
                    colors[i * 3 + 1] = brightness; // G
                    colors[i * 3 + 2] = brightness * 0.8; // B (slightly blue)
                } else if (distanceFromCenter < 100) {
                    // Disk stars - white
                    const brightness = 0.8 + Math.random() * 0.2;
                    colors[i * 3] = brightness;     // R
                    colors[i * 3 + 1] = brightness; // G
                    colors[i * 3 + 2] = brightness; // B
                } else {
                    // Background stars - various colors
                    const starType = Math.random();
                    if (starType < 0.7) {
                        // White stars
                        const brightness = 0.6 + Math.random() * 0.4;
                        colors[i * 3] = brightness;
                        colors[i * 3 + 1] = brightness;
                        colors[i * 3 + 2] = brightness;
                    } else if (starType < 0.85) {
                        // Blue stars
                        const brightness = 0.7 + Math.random() * 0.3;
                        colors[i * 3] = brightness * 0.8;
                        colors[i * 3 + 1] = brightness * 0.9;
                        colors[i * 3 + 2] = brightness;
                    } else {
                        // Red stars
                        const brightness = 0.5 + Math.random() * 0.3;
                        colors[i * 3] = brightness;
                        colors[i * 3 + 1] = brightness * 0.6;
                        colors[i * 3 + 2] = brightness * 0.4;
                    }
                }
            }

            starGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            starGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const starMaterial = new THREE.PointsMaterial({
                size: 0.08,
                vertexColors: true,
                transparent: true,
                opacity: 0.9
            });

            const starField = new THREE.Points(starGeometry, starMaterial);
            scene.add(starField);
        }

        // Create the Sun
        function createSun() {
            const sunGeometry = new THREE.SphereGeometry(2, 16, 16);
            const sunMaterial = new THREE.MeshBasicMaterial({
                color: 0xFFFF99,
                emissive: 0x444400
            });
            const sun = new THREE.Mesh(sunGeometry, sunMaterial);
            sun.position.set(12, 5, 8);
            scene.add(sun);

            // Add sun light
            const sunLight = new THREE.PointLight(0xFFFFCC, 1.5, 50);
            sunLight.position.copy(sun.position);
            scene.add(sunLight);

            return sun;
        }

        // Create additional planets
        function createOtherPlanets() {
            const planets = [];

            // Planet 1 - Rocky planet (Mars-like)
            const planet1Geometry = new THREE.SphereGeometry(0.3, 8, 8);
            const planet1Material = new THREE.MeshPhongMaterial({ color: 0xCD853F });
            const planet1 = new THREE.Mesh(planet1Geometry, planet1Material);
            planet1.position.set(25, 8, -15);
            scene.add(planet1);
            planets.push({ mesh: planet1, distance: 35, speed: 0.002 });

            // Planet 2 - Ice planet
            const planet2Geometry = new THREE.SphereGeometry(0.4, 8, 8);
            const planet2Material = new THREE.MeshPhongMaterial({ color: 0x87CEEB });
            const planet2 = new THREE.Mesh(planet2Geometry, planet2Material);
            planet2.position.set(-30, -5, 20);
            scene.add(planet2);
            planets.push({ mesh: planet2, distance: 45, speed: 0.0015 });

            // Planet 3 - Gas giant (smaller)
            const planet3Geometry = new THREE.SphereGeometry(0.6, 12, 12);
            const planet3Material = new THREE.MeshPhongMaterial({ color: 0xDDA0DD });
            const planet3 = new THREE.Mesh(planet3Geometry, planet3Material);
            planet3.position.set(20, -10, -35);
            scene.add(planet3);
            planets.push({ mesh: planet3, distance: 55, speed: 0.001 });

            return planets;
        }

        createStarfield();

        // Create sun and other planets
        sun = createSun();
        otherPlanets = createOtherPlanets();

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
